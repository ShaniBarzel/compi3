//note: this is en exemple from the tutorial //todo: delete
%{
/*USER DECLERATIONS*/
#include <iostream>
#include "calc.h"
#include "symtable.h"
#include "output.hpp"

using namespace std;
int yylex();
void yyerro(const char*);

SymbolTable* current_scope_table;

//the offsets stack. the ith entry in the stack contains the offset from the beginning of the ith scope
//to the variable to be inserted next
std::stack<int> offsets;

%}
/*DECLERATIONS*/
%token VOID BYTE B BOOL STRUCT TRUE FALSE RETURN IF WHILE BREAK CONTINUE SC COMMA PERIOD ID NUM STRING NARELOP
%left AND OR LPAREN RPAREN LBRACE RBRASCE BINOP ARELOP
%right NOT ASSIGN
%nonassoc ELSE

%%
/*RULES*/
Program :   Structs Funcs
;
Funcs :   FuncsDecl Funcs
          | /*epsilon*/
;
FuncDecl : RetType ID LPAREN Formals RPAREN {
            /* todo: paudo code
             * check if function args are legal
             * add funcion to current scope
             * create new scop table and define it as the currentScopeTable
             * insert the top offset to the offset table
             * insert all arguments as an Entries in the current scope, while updating the offset (is Entry alredy defined, is alraedy implenemted in "insert" method
             */
            }
           LBRACE Statments RBRACE{
            /* todo: psaudo code:
             * call "endScope"
             * call a function that does all the things that we were askd to do in page 6
             * delete current scope and define "CurrentScopeTable" to be it's father
             */
           }
;

Structs :   StructsDecl Structs
            | /*epsilon*/
;

StructsDecl : STRUCT ID LBRACE StructMemList RBRACE SC{
                 //insertion to current scope's table
                 if(!current_scope_table->insertVariableEntry($2.name, TYPE_STRUCT, offsets.top())){
                        errorDef(yylineno,$2.name);
                        exit(1);
                 }
                 //create new scope table for the scope defined by the struct
                 SymbolTable* new_scope_table = new SymbolTable(current_scope_table);
                 current_scope_table = new_scope_table;
                 //insert the new scope's offset to the offsets stack
                 offsets.push(offsets.top());
                 //the updating offset of the fields in the struct
                 int current_offset = offsets.top();
                 //saving a ref to fields list field of the struct defined
                 std::vector<StructMemNode>* fields_list = current_scope_table->variables_scope_table.top()->Fields;
                 //iterating over the fields list of the struct
                 for(std::vector<StructMemNode>::const_iterator it = $4.s_list->begin();it!=$4.s_list->end();it++){
                    //increment current offset by the current field's size
                    current_offset += (*it).size;
                    //insert the field as a table entry of the current scope table
                    if(!current_scope_table->insertVariableEntry((*it).name,(*it).type,(*it).size,current_offset)){
                        errorDef(yylineno,(*it).name);
                        exit(1);
                    }
                    //insert field to fields list of the defined struct
                    fields_list->push_back(*it);
                 }
                }

;

RetType : Type {
                    //todo: $$.type = $1.type ???
            }
          | VOID {
                    //todo: $$.type = VOID ???
                 }
;
Formals : FormalsList
           | /*epsilon*/
;
FormalsList : FormalDecl
                | FurmalDecl COMMA FormalsList
;
FormalDecl : Type ID
            | StructType ID {

            }
;
StructMemList : StructMem
                | StructMem StructMemList
;
StructMem : Type ID SC
;
Statements : Statement
            | Statement Statements
;
Statement : LBRACE Statements RBRACE
            | Type ID SC
            | StructType ID SC
            | STRUCT ID LBRACE StructMemList RBRACE SC
            | Type ID ASSIGN Exp SC
            | StructType ID ASSIGN Exp SC
            | ID ASSIGN Exp SC
            | ID PERIOD ID ASSIGN Exp SC
            | Call SC
            | RETURN SC{
                //todo: get to the current function by the current scope, chack if it's return type is void
            }
            | RETURN Exp SC {
                /*todo: get to the current function by the current scope, chack if it's return type is eq the exp type
                        (it can also be byte if exp type is int - page 4 rule 12)
                 */
            }
            | IF LPAREN Exp RPAREN Statement
            | IF LPAREN Exp RPAREN Statement ELSE Statement
            | WHILE LPAREN Exp RPAREN Statement
            | BREAK SC
            | CONTINUE SC
;
Call : ID LPAREN ExpList RPAREN
        | ID LPAREN RPAREN
;
ExpList : Exp
          | Exp COMME ExpList;
;
Type :   INT
        | BYTE
        | BOOL
;
StructType : STRUCT ID
;
Exp : LPAREN Exp RPAREN
      | Exp BINOP Exp{
            //binops is defined on int and byte only (among the types that we are using in this project)
            if (((dynamic_cast<ExpNode>($1)).type != TYPE_INT && (dynamic_cast<ExpNode>($1)).type != TYPE_BYTE) ||
                                    ((dynamic_cast<ExpNode>($3)).type != TYPE_INT && (dynamic_cast<ExpNode>($3)).type != TYPE_BYTE)) {
                errorMismatch(yylineo);
                exit(1);
            }
            (dynamic_cast<ExpNode>($$)).size = 1; //both INT  and BYTE are size 1
            //the exp type is the type of the bigger of the $1 and $3 expressions
            if ((dynamic_cast<ExpNode>($1)).type == TYPE_INT  || (dynamic_cast<ExpNode>($2)).type == TYPE_INT)
                (dynamic_cast<ExpNode>($$)).type = TYPE_INT;
            else
                (dynamic_cast<ExpNode>($$)).type = TYPE_BYTE;
        }

      | ID {
            //we need to check if this variable is defined in the upper or current scopes
            //if this variable is defined, we want to use it, therefore $1.type is not right, because we want the type of the variable, not the type of the token
            TableEntry* IdVariable = currentScopeTable->doesVariableExist((dynamic_cast<IdNode>($1)).name);
            if(IdVariable == nullptr){
                //the variable was never defined
                errorUndef(yylineno,(dynamic_cast<IdNode>($1)).name);
                exit(1);
            }
            // the exp type and size is the variable type and size
            (dynamic_cast<ExpNode>($$)).type = IdVariable.type;
            (dynamic_cast<ExpNode>($$)).size = IdVariable.size;
        }

      | ID PERIOD ID{
            //we need to check if this variable is defined in the upper or current scopes
            //if this variable is defined, we want to use it, therefore $1.type is not right, because we want the type of the variable, not the type of the token
            TableEntry* IdVariable = currentScopeTable->getVariableEntry(dynamic_cast<IdNode>($1)).name);
            if ((IdVariable == nullptr) || (IdVariable->sTypeName == nullptr)){
            //the variable was never defined or it's type is not a struct type
                errorUndef(yylineno,(dynamic_cast<IdNode>($1)).name);
                exit(1);
            }

            TableEntry* StructDec = currentScopeTable->getVariableEntry(IdVariable->sTypeName); //get the struct variable (Aminal for exemple), shouldn't fail, because this is the type defenition of $1
            std::vector<IdNode> StructFiledsList = StructDec->Fields; //get the list of the fileds of the struct (int age, string name, string furrColor) //todo: implement get list
                                                                              //(this is a list of variable defenitions, not variables)
            StructMemNode field;
            //search for the suitiable filed in the list
            for(std::vector<StructMemNode>::iterator it = StructFiledList.begin() ; *it != StructFiledList.end(); it++){
                if((*it).name == dynamic_cast<IdNode>($2).name){
                    field = *it; //we found the wanted field
                    break;
                }
            }
            if (field == StructFiledList.end()){ //no such filed
                errorUndefStructMember(yylineo,dynamic_cast<IdNode>($1).name);
                exit();
            }
            //else
            (dynamic_cast<ExpNode>($$)).type = field.type;
            (dynamic_cast<ExpNode>($$)).size = dynamic_cast<IdNode>($1).size;
        }

      | Call {
            //if the exp derives a function call, it's value will be the return type
            //todo: call should have ReturnType field
            (dynamic_cast<ExpNode>($$)).type = (dynamic_cast<CallNode>($1)).RetType;
            (dynamic_cast<ExpNode>($$)).type = (dynamic_cast<CallNode>($1)).RetType.size;
        }
      | NUM {
            //exp type = num type = int
            (dynamic_cast<ExpNode>($$)).type = TYPE_INT;
            (dynamic_cast<ExpNode>($$)).size = 1; //Int size is 1
        }
      | NUM B {
            //exp type = num type = byte
            (dynamic_cast<ExpNode>($$)).type = TYPE_BYTE;
            (dynamic_cast<ExpNode>($$)).size = 1; //byte size is 1
          }
      | STRING{
            //exp type = num type = string
            (dynamic_cast<ExpNode>($$)).type = TYPE_STRING;
            (dynamic_cast<ExpNode>($$)).size = 1; //string size is 1
        }
      | TRUE{
            //exp type = true type = bool
            (dynamic_cast<ExpNode>($$)).type = TYPE_BOOL;
            (dynamic_cast<ExpNode>($$)).size = 1; //bool size is 1
        }
      | FALSE{
            //exp type = false type = bool
            (dynamic_cast<ExpNode>($$)).type = TYPE_BOOL;
            (dynamic_cast<ExpNode>($$)).size = 1; //bool size is 1
        }
      | NOT Exp {
            if((dynamic_cast<ExpNode>($1)).type != TYPE_BOOL){
                //not operator is valid only on bool variables
                errorMismatch(yylineno);
                exit(1);
            }
            (dynamic_cast<ExpNode>($$)).type = TYPE_BOOL;
            (dynamic_cast<ExpNode>($$)).size = 1; //bool size is 1
          }
      | Exp AND Exp
      | Exp OR Exp
      | Exp RELOP Exp
;


%%

/*USER ROUTINES*/
void yyerror //todo: delete?
        (const char*) { cout << "syntax error" << endl; }


int main() {
    //todo: add "currentScopeTable" - global
    //todo: add "offsetsTable" vector -global
    //todo: add print and printi to the scope (this is the global scope) - page 4
    yyparse();
    //todo: check if main is missing
    //todo: delete global scope
}