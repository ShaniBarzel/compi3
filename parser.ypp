%{
/*USER DECLERATIONS*/
#define YYERROR_VERBOSE 1 //todo: for degig
#define YYDEBUG 1 //todo: for debug
#include <iostream>
#include "symtable.h"
#include "attributes.h"
#include "output.hpp"
#include <stack>
#include <cstdlib> //for exit
using namespace output; //errors defined inside the neamespace

extern int yylex();
void yyerror(std::string);
extern int yylineno;

//this will be initiated to the global scope. will be pointer to the current scope in current point in time.
SymbolTable* current_scope_table;

//the offsets stack. the ith entry in the stack contains the offset from the beginning of the ith scope
//to the variable to be inserted next
std::stack<int> offsets;

//RACHELI addition
//a boolean for knowing if we're inside a while loop
bool inside_while = false;
//a boolean for knowing weather main is defined
bool main_def = false;

//implemented at the end of the file
void printStructTypeHelp(const string& name, std::vector<StructMemNode*>* fields);
std::vector<string>* TypeVecToString(std::vector<typeName>& t_vec);
std::string typeToString(typeName type);
void closeScope(); //todo: shani
std::vector<typeName>* declToTypes(std::vector<FormalDeclNode*> decls); //todo: shani

%}
/*DECLERATIONS*/
%token VOID
%token INT
%token BYTE
%token B
%token BOOL
%token STRUCT
%token TRUE
%token FALSE
%token RETURN
%token WHILE
%token BREAK
%token CONTINUE
%token SC
%token COMMA
%token PERIOD
%token ID
%token NUM
%token STRING
%left LPAREN RPAREN LBRACE RBRACE ARELOP
%left LBINOP
%left SBINOP
%right NOT ASSIGN
%left AND
%left OR
%nonassoc NARELOP
%nonassoc IF
%nonassoc ELSE

%%
/*RULES*/

//no semantics needed
Program :  Structs Funcs
;

//no semantics needed
Funcs :   FuncDecl Funcs
          | /*epsilon*/
;

// todo: SHANI
FuncDecl :  M1 LBRACE Statements RBRACE{
                FuncDeclNode* temp1 = new FuncDeclNode();
                temp1->type = TYPE_FUNC;
                temp1->return_type = ($1)->type; //passed from marker
                $$ = temp1;
             //   cout<<"test 4: (shold be int)"<<($$)->type<<endl;
                //this function does all the things we were askd to do in page 6 when closing a scope. see function ducomentation for more details
                closeScope();
                //return the current scope to be the outer scope
                SymbolTable* parent = current_scope_table->getParent();
                delete(current_scope_table);
                 current_scope_table = parent;
                //back to the outer scope pffset
                 offsets.pop();
                                             //    cout<<"racheli debug 2: "<<yylineno<<endl;

           }
;

/* marker 1 */
M1 : RetType ID LPAREN Formals RPAREN {
        //to pass return typeto funcDecl   //todo: Shani
            ($$)->type = ($1)->type; //todo: Shani
           // cout<<"test 3: (shold be int)"<<typeToString(($$)->type)<<endl;
         //try to insert to the current symbol table
        if (!(current_scope_table->insertFunctionEntry(($2)->name, ($1)->type)))
        {
            //already exist function with this name
            errorDef(yylineno,($2)->name);
            exit(0);
        }

        TableEntryFunc* f = new TableEntryFunc();
        f = dynamic_cast<TableEntryFunc*>(current_scope_table->getEntry(($2)->name));

        //create new scope table for function scope
        SymbolTable* new_func_scope = new SymbolTable(current_scope_table);
        //the current scope is the function scope now
        current_scope_table = new_func_scope;
        //add the top value to the offsets stuck
        offsets.push(offsets.top());
        int ParamOffset = offsets.top();
        f->offset = ParamOffset;
        if (!($4->size == -1)){ //if the parameters list is not empty
            for(std::vector<FormalDeclNode*>::reverse_iterator it = (dynamic_cast<FormalsNode*>($4))->list->dec_list->rbegin(); (*it) && it != (dynamic_cast<FormalsNode*>($4))->list->dec_list->rend(); it++)
            {
        //cout<< (*it)->name <<endl; //for debug
                /*function aguments are treated as outer scope declered, there for, thire offset's are smaller than the function scope offset.
                specipicaly, the "decleration" order in the outer scope is from the right variab;e in the agruments list, to the right. */
                ParamOffset = ParamOffset - (*it)->size;
                                // cout<<"racheli test strat"<<endl;
                                 //       cout<<"name: "<<(*it)->name<<endl;
                                  //      cout<<"size: "<<(*it)->size<<endl;
                                   //     cout<<"type: "<<(*it)->type<<endl;
                                   //     cout<<"offset: "<<ParamOffset<<endl;
                                   //     cout<<"racheli test end"<<endl;
                if((*it)->type != TYPE_STRUCTID){
                        if (!(current_scope_table->insertVariableEntry((*it)->name ,(*it)->type , ParamOffset )))
                        {
                         //   cout<<(*it)->name<<endl;
                            //there is already a variable with the parameter's name
                            errorDef(yylineno, (*it)->name);
                            exit(0);
                        }
                }
                else{ //Sh
                    if (!(current_scope_table->insertStructTypeEntry( (*it)->name ,(*it)->s_name ,(*it)->type , (*it)->size,ParamOffset)))
                    {

                        //there is already a variable with the parameter's name
                        errorDef(yylineno,(*it)->name);
                        exit(0);
                    }
                    current_scope_table->getEntry((*it)->name)->offset = ParamOffset;
                }
                f->declaration_list->push_back(*it);

            }

        }
    }
;

//no semantic needed
Structs :   StructsDecl Structs
            | /*epsilon*/
;

StructsDecl :  M2 RBRACE SC{
        StructsDeclNode* temp9 = new StructsDeclNode();
        temp9->name = ($1)->name; //Sh it was ($$)->name
        temp9->size = ($1)->size; //Sh it was ($$)=>name
        temp9->s_mem_list = (dynamic_cast<StructsDeclNode*>($1))->s_mem_list;
        $$ = temp9;

                    SymbolTable* parent = current_scope_table->getParent();
                    delete(current_scope_table);
                    current_scope_table = parent;

                    offsets.pop();

        //insert struct entry to the current scope
        current_scope_table->insertStructEntry(temp9->name, TYPE_STRUCT,temp9->s_mem_list,temp9->size); //Sh


};

// marker 2
//todo update code to match new rule
//Sh : no need for 2 markers
// StructTypeDec marker
M2 : STRUCT ID LBRACE StructMemList{
        //    cout<<"racheli1: "<<yylineno<<endl;
            StructsDeclNode* temp8 = new StructsDeclNode();
            temp8->name = ($2)->name;
            temp8->type = ($1)->type;
            //insertion to current scope's table
            if (!(current_scope_table->insertStructEntry(($2)->name, TYPE_STRUCT,NULL,0))){
                    // id already defined
                    errorDef(yylineno, (($2)->name));
                    exit(0);
            }

             std::vector<StructMemNode*>* fields_list = new std::vector<StructMemNode*>();
            fields_list = (dynamic_cast<StructMemListNode*>($4))->s_list;

            StructMemListNode* dec_fields_list = new StructMemListNode();

        //todo: (racheli) i added the line bellow because if we reach here we need to pop the entry inserted in the check above
            current_scope_table->scope_table->pop_back();
            //create new scope table for the scope defined by the struct
           SymbolTable* new_scope_table = new SymbolTable(current_scope_table);
            current_scope_table = new_scope_table;
            //current_scope_table->insertStructEntry(($2)->name, TYPE_STRUCT); //Sh - this should be in the father scope
            //insert the new scope's offset to the offsets stack
            offsets.push(offsets.top());

        //the updating offset of the fields in the struct
        int current_offset = offsets.top();
        int size = 0;
        //saving a reference to "fields list" field of the struct defined
        //iterating over the fields list of the struct
        for (std::vector<StructMemNode*>::const_iterator it = fields_list->begin(); it != fields_list->end(); it++){
            //increment current offset by the current field's size
            current_offset += (*it)->size;
            size += (*it)->size;
            //insert the field as a table entry of the current scope table
            if (!(current_scope_table->insertVariableEntry((*it)->name, (*it)->type, current_offset))){
                // id already defined
                errorDef(yylineno,(*it)->name);
                exit(0);
            }
            //insert field to s_mem_list of the StructTypeDecNode
            dec_fields_list->s_list->push_back(*it);
        }
        temp8->size = size; //Sh
        temp8->s_mem_list = dec_fields_list; //Sh
        $$ = temp8; //Sh
        //delete(fields_list);
};

RetType : Type {
                    RetTypeNode* rt_node = new RetTypeNode();
                    rt_node->type = $1->type;
                    $$ = rt_node;
            }
          | VOID {
                    RetTypeNode* rt_node = new RetTypeNode();
                    rt_node->type = TYPE_VOID;
                    $$ = rt_node;
                 }
;

Formals : FormalsList {
                FormalsNode* temp2 = new FormalsNode();
                (temp2->list)->dec_list = (dynamic_cast<FormalsListNode*>($1))->dec_list;
                $$ = temp2;

            }
           | {
            FormalsNode* tempF = new FormalsNode();
            tempF->size = -1;
            $$ = tempF;} /*epsilon*/
;

FormalsList : FormalDecl {
                    FormalsListNode* temp3 = new FormalsListNode();
                    (temp3->dec_list)->push_back(dynamic_cast<FormalDeclNode*>($1));
                    $$ = temp3;
                }
             | FormalDecl COMMA FormalsList{
                    FormalsListNode* temp4 = new FormalsListNode();
                    temp4->dec_list = (dynamic_cast<FormalsListNode*>($3))->dec_list;
                    (temp4->dec_list)->push_back(dynamic_cast<FormalDeclNode*>($1));
                    $$ = temp4;
               };

FormalDecl : Type ID {
                    //RACHELI ADDITION
                    FormalDeclNode* new_node = new FormalDeclNode();
                    new_node->type = ($1)->type;
                    new_node->name = ($2)->name;
                  //  cout<<"RACHELI TEST"<<endl;
                  //  cout<<new_node->name<<endl;
                    new_node->size =1;
                    $$ = new_node;
                }//todo: function cannot get string?
            | StructType  { //Sh all
                    //s_type is "Animal"
                    /*TableEntryStructType* s_type = (TableEntryStructType*)(current_scope_table->getEntry(($1)->name));
                    if (s_type->type != TYPE_STRUCTID){
                       //no such struct
                        errorUndef(yylineno,($1)->name);
                        exit(0);
                    }*/ //already checked in StructType Rule
                    //RACHELI ADDITION
                    FormalDeclNode* new_node = new FormalDeclNode();
                    new_node->type = TYPE_STRUCTID;
                    new_node->name = ($1)->name;
                    new_node->size = ($1)->size;
                    new_node->s_name = (dynamic_cast<StructTypeNode*>($1))->structName; //Sh
                    $$ = new_node;
                 }
;

StructMemList : StructMem {
                      // // cout<<"racheli NEW"<<", "<<($1)->name<<endl;
                        StructMemListNode* temp5 = new StructMemListNode();
                        StructMemNode* temp5_1 = new StructMemNode(); //Sh
                        temp5_1 = dynamic_cast<StructMemNode*>($1); //Sh
                        //check if errorDef:
                     //   cout<<"racheli test * lineno "<<yylineno<<endl;
                        for (std::vector<StructMemNode*>::const_iterator it = temp5->s_list->begin(); it!=temp5->s_list->end(); ++it)
                        {
                         //   cout<<"here 2"<<(*it)->name<<", "<<temp5_1->name<<endl;
                            if ((*it)->name == temp5_1->name)
                            {
                           //     cout<<"bye"<<yylineno<<endl;
                                errorDef(yylineno, (*it)->name);
                                exit(0);
                            }
                        }
                        (temp5->s_list)->push_back(temp5_1);
                        $$ = temp5;
                    }
                | StructMem StructMemList{
                     //check if errorDef:
                    //    cout<<"racheli test ** lineno "<<yylineno<<endl;

                        StructMemListNode* temp6 = new StructMemListNode();
                        StructMemNode* temp6_1 = new StructMemNode(); //Sh
                        temp6_1 = dynamic_cast<StructMemNode*>($1); //Sh
                        StructMemListNode* temp6_2 = new StructMemListNode(); //Sh
                        temp6_2 = dynamic_cast<StructMemListNode*>($2); //Sh
                        temp6->s_list = temp6_2->s_list;
                        for (std::vector<StructMemNode*>::const_iterator it = temp6->s_list->begin(); it!=temp6->s_list->end(); ++it)
                        {
                           // cout<<"here "<<(*it)->name<<", "<<temp6_1->name<<endl;
                            if ((*it)->name == temp6_1->name)
                            {
                             //   cout<<"hi"<<yylineno<<endl;
                                errorDef(yylineno, (*it)->name);
                                exit(0);
                            }
                        }
                        (temp6->s_list)->push_back(temp6_1);
                        $$ = temp6;
                }
;


StructMem : Type ID SC{
                StructMemNode* temp7 = new StructMemNode();
                temp7->type = ($1)->type;
                temp7->size = 1;
                temp7->name = ($2)->name;
                $$ = temp7;
              }
;

//no semantics needed
Statements : Statement
            | Statement Statements
;

Statement : LBRACE ML Statements RBRACE
                     {// cout<<"SHANI"<<endl;
                                //this function does all the things we were askd to do in page 6 when closing a scope. see function ducomentation for more details
                                closeScope();
                                //return the current scope to be the outer scope
                                SymbolTable* parent = current_scope_table->getParent();
                                delete(current_scope_table);
                                current_scope_table = parent;
                                //back to the outer scope pffset
                                offsets.pop();
                     }
            | Type ID SC{
                int offset = offsets.top();
                offsets.pop();
                if (!(current_scope_table->insertVariableEntry(($2)->name,($1)->type,offset))){
                    // Id already defined
                    errorDef(yylineno,($2)->name);
                    exit(0);
                }
                offsets.push(offset+1); //update offset
            }

            | StructType SC {
                int offset = offsets.top();
                offsets.pop();
                if (!(current_scope_table->insertStructTypeEntry(($1)->name, (dynamic_cast<StructTypeNode*>($1))->structName,TYPE_STRUCTID,$1->size,offset))){
                    // Id already defined
                    errorDef(yylineno,($1)->name);
                    exit(0);
                 }
       // current_scope_table->getEntry(($1)->name)->offset = offsets.top(); //SHANI S
                 offsets.push(offset+1); //update offset //Sh //SHANI s

             }
             //todo: racheli, it was STRUCT ID LBRACE StructMemList RBRACE SC , i changed it to "StructsDecl" - this is another conflict
            | StructsDecl

            | Type ID ASSIGN Exp SC{
                int offset = offsets.top();
                offsets.pop();
                if (!(current_scope_table->insertVariableEntry(($2)->name,($1)->type,offset))){
                    // Id already defined
                    errorDef(yylineno,($2)->name);
                    exit(0);
                }
               // cout<<"racheli test new:"<<endl;
               // cout<<($2)->name<<endl;
                offsets.push(offset+1); //update offset
                if (($4)->type != ($1)->type){
              //  cout<<"test: "<<endl;
                                    // exp is not the same type as id
                    if ((($4)->type != TYPE_BYTE) || (($1)->type != TYPE_INT)){ // assignment of byte to int is ok
                        errorMismatch(yylineno);
                        exit(0);
                    }
                }
            }

            | StructType ASSIGN Exp SC {
              //  cout<<"test: "<<typeToString(($3)->type)<<endl;
                if (($3)->type != TYPE_STRUCTID){
                    // exp is not structType type
                    errorMismatch(yylineno);
                    exit(0);
                }
                StructTypeNode* temp11 = new StructTypeNode(""); //Sh
                temp11=dynamic_cast<StructTypeNode*>($1); //Sh
                //TableEntry* s_s_type_exp = current_scope_table->getEntry(($4)->name);
                //todo: shani: i think we can assume that exp is defined, beacuse this is being checked in the defenition of exp. dont earse it though, leave it for debug
                /* todo: for debug
                 * if(s_s_type_exp == nullptr){
                    //the variable exp was never defined
                    errorUndef(yylineno,(dynamic_cast<IdNode*>($1))->name);
                    exit(0);
                }*/

                if ((dynamic_cast<StructTypeNode*>($4))->structName != temp11->structName){
                    // exp is not the same structType type
                    errorMismatch(yylineno);
                    exit(0);
                }
                int offset = offsets.top();
                offsets.pop();
                if (!(current_scope_table->insertStructTypeEntry(temp11->name, temp11->structName,TYPE_STRUCTID,temp11->size,offset))){
                    // Id already defined
                    errorDef(yylineno,($1)->name);
                    exit(0);
                }
                offsets.push(offset+1); //update offset //Sh

             }
//todo: RACHELI from here
            | ID ASSIGN Exp SC
            {
                TableEntry* entry = current_scope_table->getEntry(($1)->name);
                //TableEntryVariable* entry = (TableEntryVariable*)(current_scope_table->getEntry(($1)->name));
                if (!entry)
                {
                    errorUndef(yylineno, ($1)->name);
                    exit(0);
                }

                //handle if struct<id>'s assignment
                if (entry->type == TYPE_STRUCTID && ($3)->type == TYPE_STRUCTID)
                {
                    TableEntryStructType* entry2 = dynamic_cast<TableEntryStructType*>(current_scope_table->getEntry(($3)->name));
                    if (!entry2)
                    {
                    errorUndef(yylineno, ($3)->name);
                    exit(0);
                    }
                    if (entry2->structName != (dynamic_cast<TableEntryStructType*>(entry))->structName)
                    {
                        errorMismatch(yylineno);
                        exit(0);
                    }
                }

                //check if valid assignment
                else if (($3)->type != entry->type /*|| ($3)->size != entry->size*/)

                {
                    //check if not a byte to int assignment
                    if (!(($3)->type == TYPE_BYTE && entry->type == TYPE_INT))
                    {
                        errorMismatch(yylineno);
                        exit(0);
                    }
                }

                //check if type of var entry is byte and
                //todo: check if strtol is ok (converts string to long int)
                //const char * c = str.c_str();

                const char * c = ((dynamic_cast<ExpNode*>($3))->value).c_str();
            //cout<<"SEGF"<<endl; //debug
                if (entry->type == TYPE_BYTE && std::strtol(c, NULL, 0) > 255)
                {
                    errorByteTooLarge(yylineno, (dynamic_cast<ExpNode*>($3))->value);
                    exit(0);
                }
            }
            | ID PERIOD ID ASSIGN Exp SC
            {
                //check if $1 is struct name and $3 is its field
                TableEntryStructType* sType = new TableEntryStructType();
                sType  = dynamic_cast<TableEntryStructType*>(current_scope_table->getEntry(($1)->name)); //Sh
                if (!sType || sType->type != TYPE_STRUCTID)
                { //no such structid
                    errorUndef(yylineno, ($1)->name);
                    exit(0);
                }

                TableEntryStruct* s = new TableEntryStruct();
                s  = dynamic_cast<TableEntryStruct*>(current_scope_table->getEntry(sType->structName)); //Sh
                if (!s || s->type != TYPE_STRUCT)
                { //no such struct
                    errorUndef(yylineno, ($1)->name);
                    exit(0);
                }

                StructMemNode* field = new StructMemNode();
                field= s->getField(($3)->name); //Sh

                if (!field)
                {
                    errorUndefStructMember(yylineno, ($1)->name);
                    exit(0);
                }
                //check types assignment match
                if (field->type != ($5)->type)
                {
                    if (!(($5)->type == TYPE_BYTE && field->type == TYPE_INT))
                    {
                        errorMismatch(yylineno);
                        exit(0);
                    }
                }

                //cout<<"RACHELI BEGIN"<<endl;
                //check if legal case type byte
                const char* c = ((dynamic_cast<ExpNode*>($5))->value).c_str();
                //cout<<"RACHELI END"<<endl;
                if (($5)->type == TYPE_BYTE && std::strtol(c, NULL, 0) > 255) {
                    errorByteTooLarge(yylineno, (dynamic_cast<ExpNode *>($5))->value);
                    exit(0);

                }

            }
            | Call SC
            | RETURN SC{
                //get current function scope
                TableEntryFunc* current_function = current_scope_table->getLastFunctionEntry();

                //error if return type of the entry isn't void
                if (current_function->return_type != TYPE_VOID)
                {
                    errorMismatch(yylineno);
                    exit(0);
                }
            }
            | RETURN Exp SC {
                TableEntryFunc* current_function = current_scope_table->getLastFunctionEntry();
                //check if Exp type can be assigned to the functions' return type
               // cout<<"test: "<<endl;
               // cout<<"current_function->return_type = "<<typeToString(current_function->return_type)<<endl;
               // cout<<"function name (shouldnt be main)"<<current_function->name<<endl;
                if (current_function->return_type != ($2)->type && !(current_function->return_type == TYPE_INT && ($2)->type == TYPE_BYTE))
                {
                    errorMismatch(yylineno);
                    exit(0);
                }
            }
            | M4 Statement{
                closeScope();
                SymbolTable* current_parent = current_scope_table->getParent();
                delete(current_scope_table);
                current_scope_table = current_parent;
                offsets.pop();
                if (($1)->err)
                {
                                   errorMismatch(($1)->line_num);
                                   exit(0);
                }

            }
            M5
            | WHILE LPAREN Exp RPAREN
               {
                    //turn on flag of loop
                    inside_while = true;
                    //check expression type
                    if (($3)->type != TYPE_BOOL)
                    {
                        errorMismatch(yylineno);
                        exit(0);
                    }
                    SymbolTable* new_scope_table = new SymbolTable(current_scope_table);
                    current_scope_table = new_scope_table;
                    offsets.push(offsets.top());
               }
               Statement
                       {
                           closeScope();
                           SymbolTable* p = current_scope_table->getParent();
                           delete(current_scope_table);
                           current_scope_table = p;
                           offsets.pop();
                           //turn off boolean marking that we're out of the while loop
                           inside_while = false;
                       }
            | BREAK SC
                {
                    if (!inside_while)
                    {
                        errorUnexpectedBreak(yylineno);
                        exit(0);
                    }
                }
            | CONTINUE SC
                {
                    if (!inside_while)
                    {
                        errorUnexpectedBreak(yylineno);
                        exit(0);
                    }
                }
;
//marker M4
M4  :  IF LPAREN Exp RPAREN {
           // Node* temp_n = new Node($1);

           // cout<<"test: "<<typeToString(($3)->type)<<endl;
            if (($3)->type != TYPE_BOOL)
            {
                ($1)->err = true;
                ($1)->line_num = yylineno;
               // errorMismatch(yylineno);
               // exit(0);
            }
            SymbolTable* new_table = new SymbolTable(current_scope_table);
            current_scope_table = new_table;
            offsets.push(offsets.top());
        }
//marker M5
M5  :  /*epsilon*/  %prec IF
        | ELSE
        {
            SymbolTable* new_scope_table = new SymbolTable(current_scope_table);
            current_scope_table = new_scope_table;
            offsets.push(offsets.top());
        }
        Statement{
            closeScope();
            SymbolTable* p = current_scope_table->getParent();
            delete(current_scope_table);
            current_scope_table = p;
            offsets.pop();
        }
        %prec ELSE
/*
//marker M7
M7  :   Statement
        {
            closeScope();
            SymbolTable* p = current_scope_table->getParent();
            delete(current_scope_table);
            current_scope_table = p;
            offsets.pop();
            //turn off boolean marking that we're out of the while loop
            inside_while = false;
        }
*/


Call : ID LPAREN ExpList RPAREN
        {
            //check that function's name isn't "main", else error

            if (($1)->name == "main")
            {
                //todo: email (what error should we return?) (main should not have parameters list)
                errorMismatch(yylineno);
                exit(0);
            }
            TableEntryFunc* f = (TableEntryFunc*)current_scope_table->getEntry(($1)->name);
            if (!f)
            {
                errorUndef(yylineno, ($1)->name);
                exit(0);
            }
                                   // cout<<"RACHELI NEW TEST"<<endl;

            //compare arguament list to declaration list
            if (!(f->compareArgumentTypes((dynamic_cast<ExpListNode*>($3))->exp_list)))
            {
                //set vector of types as strings to send as parameter to error function
                std::vector<std::string> types;
                for (std::vector<FormalDeclNode*>::const_iterator it = f->declaration_list->begin();
                     it != f->declaration_list->end(); it++)
                        {
                            //SHANI s
                            if((*it)->type == TYPE_STRUCTID){
                                types.push_back("struct "+(*it)->s_name);
                            }
                             else   //    cout<<"RACHELI NEW TEST 2"<<endl;
                                types.push_back(typeToString((*it)->type));
                        }
                errorPrototypeMismatch(yylineno, ($1)->name, types);
                exit(0);
            }
            CallNode* temp7 = new CallNode();
            temp7->return_type = f->return_type;
            $$ = temp7;
        }
        | ID LPAREN RPAREN
        {
            TableEntryFunc* f = (TableEntryFunc*)current_scope_table->getEntry(($1)->name);
            if (!f)
            {
                errorUndefFunc(yylineno, ($1)->name);
                exit(0);
            }

            //should be an empty list of args
            if (f->declaration_list->size() != 0)
            {
                //set vector of types as strings to send as parameter to error function
                std::vector<std::string> types;
                for (std::vector<FormalDeclNode*>::const_iterator it = f->declaration_list->begin();
                                            it != f->declaration_list->end(); it++)
                         {
                             types.push_back(typeToString((*it)->type));
                         }
                errorPrototypeMismatch(yylineno, ($1)->name, types);
                exit(0);
            }
            CallNode* tempC= new CallNode();
            tempC->return_type = f->return_type;
            $$ = tempC;
        }
;
//todo: RACHELI to here here

ExpList : Exp {
                // add the experssion to the expression list
                ExpListNode* temp5 = new ExpListNode();
                (temp5->exp_list)->push_back(dynamic_cast<ExpNode*>($1));
                $$ = temp5;
            }
          | Exp COMMA ExpList {
                ExpListNode* temp6 = new ExpListNode();
                temp6->exp_list = (dynamic_cast<ExpListNode*>($3))->exp_list;
                (temp6->exp_list)->push_back(dynamic_cast<ExpNode*>($1));
                $$ = temp6;
                //current list will be the list it derives with the exp is derives
            }
;

Type :   INT{
                TypeNode* t_node = new TypeNode();
                t_node->type = TYPE_INT;
                t_node->value = TYPE_INT;
                $$ = t_node;
             }
        | BYTE{
                TypeNode* t_node = new TypeNode();
                t_node->type = TYPE_BYTE;
                t_node->value = TYPE_BYTE;
                $$ = t_node;
                }
        | BOOL{                TypeNode* t_node = new TypeNode();
                               t_node->type = TYPE_BOOL;
                               t_node->value = TYPE_BOOL;
                               $$ = t_node;
                    }
;

StructType : STRUCT ID ID{ //Sh all
                TableEntryStruct* IdVariable = (TableEntryStruct*)current_scope_table->getEntry(($2)->name);
                if(!IdVariable){
                    //the struct was never defined
                    errorUndefStruct(yylineno,($2)->name);
                    exit(0);
                }
                StructTypeNode* temp10 = new StructTypeNode($2->name);
                temp10->type = TYPE_STRUCTID;
                temp10->name = ($3)->name;
                temp10->size = IdVariable->size;
               // temp10->offset = offsets.top();
                $$ = temp10;
            }
;

ML :  { /* epsilon */
    //todo: shani: has to seperate the open scope and the close scope
    //create new scope table for the scope
    SymbolTable* new_scope = new SymbolTable(current_scope_table);
    //the current scope is the new scope now
    current_scope_table = new_scope;
    //add the top value to the offsets stuck
    offsets.push(offsets.top());
};

Exp : LPAREN Exp RPAREN{
            $$->type = $2->type;
            $$->size = $2->size;
      }

      | Exp SBINOP Exp{
            //binops is defined on int and byte only (among the types that we are using in this project)
            if ((($1)->type != TYPE_INT && ($1)->type != TYPE_BYTE) || (($3)->type != TYPE_INT && ($3)->type != TYPE_BYTE)) {
                errorMismatch(yylineno);
                exit(0);
            }
            ($$)->size = 1; //both INT  and BYTE are size 1
            //the exp type is the type of the bigger of the $1 and $3 expressions
            if (($1)->type == TYPE_INT  || ($3)->type == TYPE_INT)
                ($$)->type = TYPE_INT;
            else
                ($$)->type = TYPE_BYTE;
        }
      | Exp LBINOP Exp{
            //binops is defined on int and byte only (among the types that we are using in this project)
            if ((($1)->type != TYPE_INT && ($1)->type != TYPE_BYTE) || (($3)->type != TYPE_INT && ($3)->type != TYPE_BYTE)) {
                errorMismatch(yylineno);
                exit(0);
            }
            ($$)->size = 1; //both INT  and BYTE are size 1
            //the exp type is the type of the bigger of the $1 and $3 expressions
            if (($1)->type == TYPE_INT  || ($3)->type == TYPE_INT)
                    ($$)->type = TYPE_INT;
            else
                ($$)->type = TYPE_BYTE;
        }
        | ID {
            //we need to check if this variable is defined in the upper or current scopes
            //if this variable is defined, we want to use it, therefore $1.type is not right, because we want the type of the variable, not the type of the token
            TableEntry* IdVariable = current_scope_table->getEntry(($1)->name);
            if(!IdVariable){
                //the variable was never defined
                errorUndef(yylineno,($1)->name);
                exit(0);
            }
            //SHANI S

            // the exp type and size is the variable type and size
            ExpNode* tempID = new ExpNode($1->name);
            if (IdVariable->type == TYPE_STRUCTID){
                    TableEntryStructType* sType = new TableEntryStructType();
                    sType  = dynamic_cast<TableEntryStructType*>(current_scope_table->getEntry(($1)->name)); //Sh
                    if (!sType || sType->type != TYPE_STRUCTID)
                    { //no such structid
                        errorUndef(yylineno, ($1)->name);
                        exit(0);
                    }

                    TableEntryStruct* s = new TableEntryStruct();
                    s  = dynamic_cast<TableEntryStruct*>(current_scope_table->getEntry(sType->structName)); //Sh
                    if (!s || s->type != TYPE_STRUCT)
                    { //no such struct
                        errorUndef(yylineno, sType->structName);
                        exit(0);
                    }

                    tempID->s_name = sType->structName; //Sh
            }
            tempID->type = IdVariable->type;
            tempID->size = IdVariable->size;
            tempID->name = IdVariable->name;
            $$ = tempID;
        }

      | ID PERIOD ID{
            //check if $1 is struct name and $3 is its field
            TableEntryStructType* sType = new TableEntryStructType();
            sType  = dynamic_cast<TableEntryStructType*>(current_scope_table->getEntry(($1)->name)); //Sh
            if (!sType || sType->type != TYPE_STRUCTID)
            { //no such structid
                errorUndef(yylineno, ($1)->name);
                exit(0);
            }

            TableEntryStruct* s = new TableEntryStruct();
            s  = dynamic_cast<TableEntryStruct*>(current_scope_table->getEntry(sType->structName)); //Sh
            if (!s || s->type != TYPE_STRUCT)
            { //no such struct
                errorUndef(yylineno, sType->structName);
                exit(0);
            }

            StructMemNode* field = new StructMemNode();
            field= s->getField(($3)->name); //Sh

            if (!field)
            {
                errorUndefStructMember(yylineno, ($1)->name);
                exit(0);
            }
            ExpNode* tempIDID = new ExpNode("");
            tempIDID->type = field->type;
            //cout<<"test2:"<<typeToString(($$)->type)<<endl;
            tempIDID->size = ($1)->size;
            $$ = tempIDID;
        }

      | Call {
            //if the exp derives a function call, it's value will be the return type
            //todo: call should have ReturnType field
                ExpNode* tempCall = new ExpNode("");
            tempCall->type = (dynamic_cast<CallNode*>($1))->return_type;
           // tempCall->size = (dynamic_cast<CallNode*>($1))->size;
            $$=tempCall;
        }

      | NUM {
            ExpNode* tempE1 = new ExpNode(($1)->name);
            //exp type = num type = int
            tempE1->type = TYPE_INT;
            tempE1->size = 1; //Int size is 1
            tempE1->value = ($1)->name;
            $$ = tempE1;
        }

      | NUM B {
                const char * c = ((($1))->name).c_str();
                              if (std::strtol(c, NULL, 0) > 255)
                              {
                                  errorByteTooLarge(yylineno, (($1))->name);
                                  exit(0);
                              }
            //exp type = num type = byte
            ExpNode* tempE2 = new ExpNode(($1)->name);
            tempE2->type = TYPE_BYTE;
            tempE2->size = 1; //byte size is 1
            tempE2->value = ($1)->name;
             $$ = tempE2;
          }

      | STRING{
            ExpNode* tempE3 = new ExpNode(($1)->name);
            //exp type = num type = string
            tempE3->type = TYPE_STRING;
            tempE3->size = 1; //string size is 1
            tempE3->value = ($1)->name;
            ($$)=tempE3;
        }

      | TRUE{
            //exp type = true type = bool
            ExpNode* tempE4 = new ExpNode(($1)->name);
            tempE4->type = TYPE_BOOL;
            tempE4->size = 1; //bool size is 1
            tempE4->value = ($1)->name;
            ($$)=tempE4;
        }

      | FALSE{
            ExpNode* tempE5 = new ExpNode(($1)->name);
            //exp type = false type = bool
            tempE5->type = TYPE_BOOL;
            tempE5->size = 1; //bool size is 1
            tempE5->value = ($1)->name;
            ($$)=tempE5;
        }

      | NOT Exp {
            if(($2)->type != TYPE_BOOL){
                //not operator is valid only on bool variables
                errorMismatch(yylineno);
                exit(0);
            }
            ExpNode* tempEx5 = new ExpNode("");
            tempEx5->type = TYPE_BOOL;
            tempEx5->size = 1; //bool size is 1
                    $$=tempEx5;
          }

      | Exp AND Exp{
            if(($1)->type != TYPE_BOOL || ($3)->type != TYPE_BOOL){
                //and operator is valid only on bool variables
                errorMismatch(yylineno);
                exit(0);
            }
            ExpNode* tempEx4 = new ExpNode("");
            tempEx4->type = TYPE_BOOL;
            tempEx4->size = 1; //bool size is 1
                    $$=tempEx4;
        }
      | Exp OR Exp{
            if (($1)->type != TYPE_BOOL || ($3)->type != TYPE_BOOL){
            //or operator is valid only on bool variables
                errorMismatch(yylineno);
                exit(0);
            }
            ExpNode* tempEx3 = new ExpNode("");
            tempEx3->type = TYPE_BOOL;
            tempEx3->size = 1; //bool size is 1
                    $$ = tempEx3;
       }

      | Exp ARELOP Exp{
            //cout<<"types: "<<typeToString(($1)->type)<<", "<<typeToString(($3)->type)<<endl;
            if ((($1)->type != TYPE_INT && ($1)->type != TYPE_BYTE) || (($3)->type != TYPE_BYTE && ($3)->type != TYPE_INT)){
               // cout<<"Test: "<<endl;
                //and operator is valid only on numerical variables
                errorMismatch(yylineno);
                exit(0);
            }
            ExpNode* tempEx2 = new ExpNode("");
            tempEx2->type = TYPE_BOOL; // return type of relop operator is bool
            tempEx2->size = 1; //bool size is 1
                    $$=tempEx2;
       }

      | Exp NARELOP Exp{
        if ((($1)->type != TYPE_INT && ($1)->type != TYPE_BYTE) || (($3)->type != TYPE_BYTE && ($3)->type != TYPE_INT)){
            //and operator is valid only on numerical variables
            errorMismatch(yylineno);
            exit(0);
        }
        ExpNode* tempEx1 = new ExpNode("");
        tempEx1->type = TYPE_BOOL; // return type of relop operator is bool
        tempEx1->size = 1; //bool size is 1
                $$ = tempEx1;
       }
;


%%

/*USER ROUTINES*/

//todo: RACHELI

void yyerror(std::string m)
{
   // endScope();
    //todo: why do we need an input to this function?
    errorSyn(yylineno);
    exit(0);
}

int main() {
   //yydebug = 1; //todo: for debug
    SymbolTable* temp_table = new SymbolTable(NULL);
    current_scope_table = temp_table;
    offsets.push(0);
    //std::vector<FormalDeclNode*> decl_list;
    FormalDeclNode* n = new FormalDeclNode();
    n->name = "";
    n->type = TYPE_STRING;
    n->size = 1;
    current_scope_table->insertFunctionEntry("print", TYPE_VOID);
    TableEntryFunc* f_print = (TableEntryFunc*)current_scope_table->getEntry("print");
    f_print->declaration_list->push_back(n);
    FormalDeclNode* n2 = new FormalDeclNode();
    n2->name = "";
    n2->type = TYPE_INT;
    n2->size = 1;
    current_scope_table->insertFunctionEntry("printi", TYPE_VOID);
    TableEntryFunc* f_printi = (TableEntryFunc*)current_scope_table->getEntry("printi");
    f_printi->declaration_list->push_back(n2);
    yyparse();
    int main_counter = 0;
    for (std::vector<TableEntry*>::const_iterator it = current_scope_table->scope_table->begin(); it != current_scope_table->scope_table->end(); it++)
    {
        if (((TableEntryFunc*)(*it))->type ==TYPE_FUNC)
        {
            if ((*it)->name == "main" && ((TableEntryFunc*)(*it))->return_type == TYPE_VOID && ((TableEntryFunc*)(*it))->declaration_list->size() == 0)
            {
                main_counter++;
            }
        }

    }
    if (main_counter != 1)
    {
        errorMainMissing();
        exit(0);
    }
    closeScope();
    delete(temp_table);
}


void printStructTypeHelp(const string& name, std::vector<StructMemNode*>* fields){
    std::vector<typeName>* Types = new std::vector<typeName>();
    std::vector<string>* Names = new std::vector<string>();
    //if (*(fields->begin()))
       // cout<<"OK"<<endl;
    for(std::vector<StructMemNode*>::reverse_iterator it = fields->rbegin();it!=fields->rend();it++){
        Types->push_back((*it)->type);
        Names->push_back((*it)->name);
    }
   // cout<<"RACHELI TEST CONT 2"<<endl;
    printStructType(name, *(TypeVecToString(*Types)), *Names);
}
//todo: (racheli) TYPE_STRUCTID
std::string typeToString(typeName type){
    //cout<<"846"<<endl; //for debug
    switch (type){
        case(TYPE_BYTE) :
            return "BYTE";
        case(TYPE_BOOL) :
            return "BOOL";
        case(TYPE_INT) :
            return "INT";
        case(TYPE_STRING) :
            return "STRING";
        case(TYPE_STRUCT) :
            return "STRUCT";
        case(TYPE_STRUCTID) :
            return "STRUCTID";
        case(TYPE_VOID) :
            return "VOID";
    }
}

std::vector<string>* TypeVecToString(std::vector<typeName>& t_vec){
    std::vector<string>* s_vec = new std::vector<string>();

    for(int i=0; i< t_vec.size(); i++){
       s_vec->push_back(typeToString(t_vec[i]));
    }

    return s_vec;
}

std::vector<typeName>* declToTypes(std::vector<FormalDeclNode*>* decls){
    std::vector<typeName>* res = new std::vector<typeName>();
    for(std::vector<FormalDeclNode*>::const_iterator it = decls->begin(); it != decls->end(); it++){
        if (typeToString((*it)->type) == "STRUCTID")
        //    cout<<"test: struct " << (*it)->s_name<<endl;
        res->push_back((*it)->type);
    }
    return res;
}

std::vector<std::string>* declToStrings(std::vector<FormalDeclNode*>* decl)
{
    std::vector<std::string>* res = new std::vector<std::string>();
    for(std::vector<FormalDeclNode*>::const_iterator it = decl->begin(); it != decl->end(); ++it)
    {
        typeName type_temp = (*it)->type;
        if (typeToString(type_temp) != "STRUCTID")
            res->push_back(typeToString(type_temp));
        else
            res->push_back("struct "+(*it)->s_name);
    }
    return res;
}

//todo: shani
void closeScope() {
        endScope();

    //note: type will never be struct (//todo: shani: racheli, i did not implimanted it for struct because you already did in another function)) 11.12 change: i changed it because of the FAQ
    //todo: should we support nested functions?
    //for all arguments in the scope table, print them
    for (std::vector<TableEntry*>::const_iterator it = (current_scope_table->scope_table)->begin(); it != (current_scope_table->scope_table)->end(); it++) {
        // cout<<"test new"<<endl;
        //if ((*it)->name == "x")
        // cout<<"good"<<endl;
        if ((*it)->type == TYPE_FUNC) {
            //cout<<"887"<<endl; //for debug
            //we should print by using "makeFunctionType" in this case
           // cout<<"TEST: "<<typeToString((dynamic_cast<TableEntryFunc*>(*it))->return_type)<<endl;
            output::printID((*it)->name, (*it)->offset,
                            makeFunctionType(typeToString(dynamic_cast<TableEntryFunc*>((*it))->return_type), *(declToStrings
                                                (((TableEntryFunc *) (*it))->declaration_list))));
        } else if ((*it)->type == TYPE_STRUCTID) {
            //note: "+" is string concatenation operator
            printID((*it)->name, (*it)->offset, ("struct " + ((TableEntryStructType *) (*it))->structName));
        } else if ((*it)->type == TYPE_STRUCT) {
            //do nothing
        } else {
            printID((*it)->name, (*it)->offset, typeToString((*it)->type));
        }
    }
        for (std::vector<TableEntry*>::const_iterator it2 = (current_scope_table->scope_table)->begin(); it2 != (current_scope_table->scope_table)->end(); it2++) {
            if ((*it2)->type != TYPE_STRUCT) {
                    //do nothing
             }
            else { // type is struct
                TableEntryStruct* structInfo = (TableEntryStruct*)(*it2);
                printStructTypeHelp(structInfo->name, structInfo->Fields->s_list);
            }
    }

}