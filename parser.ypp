%{
/*USER DECLERATIONS*/
//#define YYERROR_VERBOSE 1 //todo: for degbug
#define YYDEBUG 1 //todo: for debug
#include <iostream>
#include "symtable.h"
#include "attributes.h"
#include "output.hpp"
#include <stack>
#include <cstdlib> //for exit
#include "bp.h"
using namespace output; //errors defined inside the neamespace

extern int yylex();
void yyerror(std::string);
extern int yylineno;

//this will be initiated to the global scope. will be pointer to the current scope in current point in time.
SymbolTable* current_scope_table;

//the offsets stack. the ith entry in the stack contains the offset from the beginning of the ith scope
//to the variable to be inserted next
std::stack<int> offsets;

//RACHELI addition
//a boolean for knowing if we're inside a while loop
bool inside_while = false;
//a boolean for knowing weather main is defined
bool main_def = false;

//implemented at the end of the file
void printStructTypeHelp(const string& name, std::vector<StructMemNode*>* fields);
std::vector<string>* TypeVecToString(std::vector<typeName>& t_vec);
std::string typeToString(typeName type);
void closeScope();
std::vector<typeName>* declToTypes(std::vector<FormalDeclNode*> decls);

//09.01.2019
std::vector<bool> AvailRegs(NUM_OF_TEMP_REGS,true); //init all register to be free to use
// this function both finds the first avil register and marks it as used
TempReg getAvailReg(){
    for(int i=0; i< NUM_OF_TEMP_REGS; i++){
        if (AvailRegs[i]){
            AvailRegs[i] = false;
            return (TempReg)i;
        }
        return (TempReg)i; //no available registers
    }
}
// this function marks a register as unused
void returnTempReg(TempReg ret){AvailRegs[ret]=false;}


%}
/*DECLERATIONS*/
%token VOID
%token INT
%token BYTE
%token B
%token BOOL
%token STRUCT
%token TRUE
%token FALSE
%token RETURN
%token WHILE
%token BREAK
%token CONTINUE
%token SC
%token COMMA
%token PERIOD
%token ID
%token NUM
%token STRING
%left LPAREN RPAREN LBRACE RBRACE
%right NOT ASSIGN
%left AND
%left OR
%nonassoc SMALLER BIGGER BEQ SEQ
%left EQUAL NOTEQUAL
%left PLUS MINUS
%left MUL DIV
%nonassoc IF
%nonassoc ELSE

%%
/*RULES*/

//no semantics needed
Program :  Structs Funcs
;

//no semantics needed
Funcs :   FuncDecl Funcs
          | /*epsilon*/
;


FuncDecl :  M1 LBRACE Statements RBRACE{
                FuncDeclNode* temp1 = new FuncDeclNode();
                temp1->type = TYPE_FUNC;
                temp1->return_type = ($1)->type; //passed from marker
                $$ = temp1;
                //this function does all the things we were askd to do in page 6 when closing a scope. see function ducomentation for more details
                closeScope();
                //return the current scope to be the outer scope
                SymbolTable* parent = current_scope_table->getParent();
                delete(current_scope_table);
                 current_scope_table = parent;
                //back to the outer scope pffset
                 offsets.pop();
           }
;

/* marker 1 */
M1 : RetType ID LPAREN Formals RPAREN {
        //to pass return typeto funcDecl
         ($$)->type = ($1)->type;
         //try to insert to the current symbol table
        if (!(current_scope_table->insertFunctionEntry(($2)->name, ($1)->type)))
        {
            //already exist function with this name
            errorDef(yylineno,($2)->name);
            exit(0);
        }

        TableEntryFunc* f = new TableEntryFunc();
        f = dynamic_cast<TableEntryFunc*>(current_scope_table->getEntry(($2)->name));

        //create new scope table for function scope
        SymbolTable* new_func_scope = new SymbolTable(current_scope_table);
        //the current scope is the function scope now
        current_scope_table = new_func_scope;
        //add the top value to the offsets stuck
        offsets.push(offsets.top());
        int ParamOffset = offsets.top();
        f->offset = ParamOffset;
        if (!($4->size == -1)){ //if the parameters list is not empty
            for(std::vector<FormalDeclNode*>::reverse_iterator it = (dynamic_cast<FormalsNode*>($4))->list->dec_list->rbegin(); (*it) && it != (dynamic_cast<FormalsNode*>($4))->list->dec_list->rend(); it++)
            {
                /*function aguments are treated as outer scope declered, there for, thire offset's are smaller than the function scope offset.
                specipicaly, the "decleration" order in the outer scope is from the right variable in the agruments list, to the right. */
                ParamOffset = ParamOffset - (*it)->size;

                if((*it)->type != TYPE_STRUCTID){
                        if (!(current_scope_table->insertVariableEntry((*it)->name ,(*it)->type , ParamOffset )))
                        {
                            //there is already a variable with the parameter's name
                            errorDef(yylineno, (*it)->name);
                            exit(0);
                        }
                }
                else{
                    if (!(current_scope_table->insertStructTypeEntry( (*it)->name ,(*it)->s_name ,(*it)->type , (*it)->size,ParamOffset)))
                    {
                        //there is already a variable with the parameter's name
                        errorDef(yylineno,(*it)->name);
                        exit(0);
                    }
                    current_scope_table->getEntry((*it)->name)->offset = ParamOffset;
                }
                f->declaration_list->push_back(*it);

            }

        }
    }
;

//no semantic needed
Structs :   StructsDecl Structs
            | /*epsilon*/
;

StructsDecl :  M2 RBRACE SC{
        StructsDeclNode* temp9 = new StructsDeclNode();
        temp9->name = ($1)->name;
        temp9->size = ($1)->size;
        temp9->s_mem_list = (dynamic_cast<StructsDeclNode*>($1))->s_mem_list;
        $$ = temp9;
        SymbolTable* parent = current_scope_table->getParent();
        delete(current_scope_table);
        current_scope_table = parent;
        offsets.pop();

        //insert struct entry to the current scope
        current_scope_table->insertStructEntry(temp9->name, TYPE_STRUCT,temp9->s_mem_list,temp9->size);

};

// marker 2
M2 : STRUCT ID LBRACE StructMemList{
            StructsDeclNode* temp8 = new StructsDeclNode();
            temp8->name = ($2)->name;
            temp8->type = ($1)->type;
            //insertion to current scope's table
            if (!(current_scope_table->insertStructEntry(($2)->name, TYPE_STRUCT,NULL,0))){
                    // id already defined
                    errorDef(yylineno - 1 - (dynamic_cast<StructMemListNode*>($4))->s_list->size(), (($2)->name));  //fixed racheli appeal
                    exit(0);
            }

             std::vector<StructMemNode*>* fields_list = new std::vector<StructMemNode*>();
            fields_list = (dynamic_cast<StructMemListNode*>($4))->s_list;

            StructMemListNode* dec_fields_list = new StructMemListNode();

            current_scope_table->scope_table->pop_back();
            //create new scope table for the scope defined by the struct
            SymbolTable* new_scope_table = new SymbolTable(current_scope_table);
            current_scope_table = new_scope_table;
            //insert the new scope's offset to the offsets stack
            offsets.push(offsets.top());

        //the updating offset of the fields in the struct
        int current_offset = offsets.top();
        int size = 0;
        //saving a reference to "fields list" field of the struct defined
        //iterating over the fields list of the struct
        for (std::vector<StructMemNode*>::const_iterator it = fields_list->begin(); it != fields_list->end(); it++){
            //increment current offset by the current field's size
            current_offset += (*it)->size;
            size += (*it)->size;
            //insert the field as a table entry of the current scope table
            if (!(current_scope_table->insertVariableEntry((*it)->name, (*it)->type, current_offset))){
                // id already defined
                errorDef(yylineno,(*it)->name);
                exit(0);
            }
            //insert field to s_mem_list of the StructTypeDecNode
            dec_fields_list->s_list->push_back(*it);
        }
        temp8->size = size;
        temp8->s_mem_list = dec_fields_list;
        $$ = temp8;
};

RetType : Type {
                    RetTypeNode* rt_node = new RetTypeNode();
                    rt_node->type = $1->type;
                    $$ = rt_node;
            }
          | VOID {
                    RetTypeNode* rt_node = new RetTypeNode();
                    rt_node->type = TYPE_VOID;
                    $$ = rt_node;
                 }
;

Formals : FormalsList {
                FormalsNode* temp2 = new FormalsNode();
                (temp2->list)->dec_list = (dynamic_cast<FormalsListNode*>($1))->dec_list;
                $$ = temp2;

            }
           | {
            FormalsNode* tempF = new FormalsNode();
            tempF->size = -1;
            $$ = tempF;} /*epsilon*/
;

FormalsList : FormalDecl {
                    FormalsListNode* temp3 = new FormalsListNode();
                    (temp3->dec_list)->push_back(dynamic_cast<FormalDeclNode*>($1));
                    $$ = temp3;
                }
             | FormalDecl COMMA FormalsList{
                    FormalsListNode* temp4 = new FormalsListNode();
                    temp4->dec_list = (dynamic_cast<FormalsListNode*>($3))->dec_list;
                    (temp4->dec_list)->push_back(dynamic_cast<FormalDeclNode*>($1));
                    $$ = temp4;
               };

FormalDecl : Type ID {

                    FormalDeclNode* new_node = new FormalDeclNode();
                    new_node->type = ($1)->type;
                    new_node->name = ($2)->name;
                    new_node->size =1;
                    $$ = new_node;
                }
            | StructType  {
                    FormalDeclNode* new_node = new FormalDeclNode();
                    new_node->type = TYPE_STRUCTID;
                    new_node->name = ($1)->name;
                    new_node->size = ($1)->size;
                    new_node->s_name = (dynamic_cast<StructTypeNode*>($1))->structName;
                    $$ = new_node;
                 }
;

StructMemList : StructMem {
                        StructMemListNode* temp5 = new StructMemListNode();
                        StructMemNode* temp5_1 = new StructMemNode();
                        temp5_1 = dynamic_cast<StructMemNode*>($1);
                        for (std::vector<StructMemNode*>::const_iterator it = temp5->s_list->begin(); it!=temp5->s_list->end(); ++it)
                        {
                            if ((*it)->name == temp5_1->name)
                            {
                                errorDef(($1)->line_num, (*it)->name);
                                exit(0);
                            }
                        }
                            std::vector<StructMemNode*>::iterator it = temp5->s_list->begin();
                        (temp5->s_list)->insert(it, temp5_1);
                        temp5->line_num = ($1)->line_num;
                        temp5->lineNumberStart = ($1)->line_num - ($1)->size;
                        $$ = temp5;
                    }
                | StructMem StructMemList{
                        StructMemListNode* temp6 = new StructMemListNode();
                        StructMemNode* temp6_1 = new StructMemNode();
                        temp6_1 = dynamic_cast<StructMemNode*>($1);
                        StructMemListNode* temp6_2 = new StructMemListNode();
                        temp6_2 = dynamic_cast<StructMemListNode*>($2);
                        temp6->s_list = temp6_2->s_list;
                        std::vector<StructMemNode*>::iterator it = temp6->s_list->begin();
                        (temp6->s_list)->push_back( temp6_1);
                        $$ = temp6;
                }
;

StructMem : Type ID SC{
                StructMemNode* temp7 = new StructMemNode();
                temp7->type = ($1)->type;
                temp7->size = 1;
                temp7->name = ($2)->name;
                temp7->line_num = yylineno;
                $$ = temp7;
              }
;

//no semantics needed
Statements : Statement
            | Statement Statements
;

Statement : LBRACE ML Statements RBRACE
                  {
                      //this function does all the things we were askd to do in page 6 when closing a scope. see function ducomentation for more details
                      closeScope();
                      //return the current scope to be the outer scope
                      SymbolTable* parent = current_scope_table->getParent();
                      delete(current_scope_table);
                      current_scope_table = parent;
                      //back to the outer scope offset
                      offsets.pop();
                  }
            | Type ID SC{
                int offset = offsets.top();
                offsets.pop();
                if (!(current_scope_table->insertVariableEntry(($2)->name,($1)->type,offset))){
                    // Id already defined
                    errorDef(yylineno,($2)->name);
                    exit(0);
                }
                offsets.push(offset+1); //update offset
            }

            | StructType SC {
                int offset = offsets.top();
                offsets.pop();
                if (!(current_scope_table->insertStructTypeEntry(($1)->name, (dynamic_cast<StructTypeNode*>($1))->structName,TYPE_STRUCTID,$1->size,offset))){
                    // Id already defined
                    errorDef(yylineno,($1)->name);
                    exit(0);
                 }
                 offsets.push(offset+($1)->size); //update offset //Fixed

             }

            | StructsDecl

            | Type ID ASSIGN Exp SC{
                int offset = offsets.top();
                offsets.pop();
                if (!(current_scope_table->insertVariableEntry(($2)->name,($1)->type,offset))){
                    // Id already defined
                    errorDef(yylineno,($2)->name);
                    exit(0);
                }
                offsets.push(offset+1); //update offset
                if (($4)->type != ($1)->type){
                    // exp is not the same type as id
                    if ((($4)->type != TYPE_BYTE) || (($1)->type != TYPE_INT)){ // assignment of byte to int is ok
                        errorMismatch(yylineno);
                        exit(0);
                    }
                }
            }

            | StructType ASSIGN Exp SC {
                if (($3)->type != TYPE_STRUCTID){
                    // exp is not structType type
                    errorMismatch(yylineno);
                    exit(0);
                }
                StructTypeNode* temp11 = new StructTypeNode("");
                temp11=dynamic_cast<StructTypeNode*>($1);
                if ((dynamic_cast<StructTypeNode*>($4))->structName != temp11->structName){
                    // exp is not the same structType type
                    errorMismatch(yylineno);
                    exit(0);
                }
                int offset = offsets.top();
                offsets.pop();
                if (!(current_scope_table->insertStructTypeEntry(temp11->name, temp11->structName,TYPE_STRUCTID,temp11->size,offset))){
                    // Id already defined
                    errorDef(yylineno,($1)->name);
                    exit(0);
                }
                offsets.push(offset+($1)->size); //update offset //Fixed

             }

            | ID ASSIGN Exp SC
            {
                TableEntry* entry = current_scope_table->getEntry(($1)->name);
                if (!entry || entry->type == TYPE_FUNC || entry->type == TYPE_STRUCT) //Fixed: func and struct are not assigenable
                {
                    errorUndef(yylineno, ($1)->name);
                    exit(0);
                }

                //handle if struct<id>'s assignment
                if (entry->type == TYPE_STRUCTID && ($3)->type == TYPE_STRUCTID)
                {
                    TableEntryStructType* entry2 = dynamic_cast<TableEntryStructType*>(current_scope_table->getEntry(($3)->name));
                    if (!entry2)
                    {
                    errorUndef(yylineno, ($3)->name);
                    exit(0);
                    }
                    if (entry2->structName != (dynamic_cast<TableEntryStructType*>(entry))->structName)
                    {
                        errorMismatch(yylineno);
                        exit(0);
                    }
                }

                //check if valid assignment
                else if (($3)->type != entry->type /*|| ($3)->size != entry->size*/)

                {
                    //check if not a byte to int assignment
                    if (!(($3)->type == TYPE_BYTE && entry->type == TYPE_INT))
                    {
                        errorMismatch(yylineno);
                        exit(0);
                    }
                }

                //check if type of var entry is byte and
                const char * c = ((dynamic_cast<ExpNode*>($3))->value).c_str();
                if (entry->type == TYPE_BYTE && std::strtol(c, NULL, 0) > 255)
                {
                    errorByteTooLarge(yylineno, (dynamic_cast<ExpNode*>($3))->value);
                    exit(0);
                }
            }
            | ID PERIOD ID ASSIGN Exp SC
            {
                //check if $1 is struct name and $3 is its field
                TableEntryStructType* sType = new TableEntryStructType();
                sType  = dynamic_cast<TableEntryStructType*>(current_scope_table->getEntry(($1)->name));
                if (!sType || sType->type != TYPE_STRUCTID)
                { //no such structid
                    errorUndef(yylineno, ($1)->name);
                    exit(0);
                }

                TableEntryStruct* s = new TableEntryStruct();
                s  = dynamic_cast<TableEntryStruct*>(current_scope_table->getEntry(sType->structName));
                if (!s || s->type != TYPE_STRUCT)
                { //no such struct
                    errorUndef(yylineno, ($1)->name);
                    exit(0);
                }

                StructMemNode* field = new StructMemNode();
                field= s->getField(($3)->name);

                if (!field)
                {
                    errorUndefStructMember(yylineno, ($1)->name);
                    exit(0);
                }
                //check types assignment match
                if (field->type != ($5)->type)
                {
                    if (!(($5)->type == TYPE_BYTE && field->type == TYPE_INT))
                    {
                        errorMismatch(yylineno);
                        exit(0);
                    }
                }

                const char* c = ((dynamic_cast<ExpNode*>($5))->value).c_str();
                if (($5)->type == TYPE_BYTE && std::strtol(c, NULL, 0) > 255) {
                    errorByteTooLarge(yylineno, (dynamic_cast<ExpNode *>($5))->value);
                    exit(0);

                }

            }
            | Call SC
            | RETURN SC{
                //get current function scope
                TableEntryFunc* current_function = current_scope_table->getLastFunctionEntry();

                //error if return type of the entry isn't void
                if (current_function->return_type != TYPE_VOID)
                {
                    errorMismatch(yylineno);
                    exit(0);
                }
            }
            | RETURN Exp SC {
                TableEntryFunc* current_function = current_scope_table->getLastFunctionEntry();
                //check if Exp type can be assigned to the functions' return type
                if (current_function->return_type != ($2)->type && !(current_function->return_type == TYPE_INT && ($2)->type == TYPE_BYTE))
                {
                    errorMismatch(yylineno);
                    exit(0);
                }
            }
            | M4 Statement{
                closeScope();
                SymbolTable* current_parent = current_scope_table->getParent();
                delete(current_scope_table);
                current_scope_table = current_parent;
                offsets.pop();
                if (($1)->err)
                {
                   errorMismatch(($1)->line_num);
                   exit(0);
                }

            }
            M5
            | WHILE LPAREN Exp RPAREN
               {
                    //turn on flag of loop
                    inside_while = true;
                    //check expression type
                    if (($3)->type != TYPE_BOOL)
                    {
                        errorMismatch(yylineno);
                        exit(0);
                    }
                    SymbolTable* new_scope_table = new SymbolTable(current_scope_table);
                    current_scope_table = new_scope_table;
                    offsets.push(offsets.top());
               }
               Statement
                       {
                           closeScope();
                           SymbolTable* p = current_scope_table->getParent();
                           delete(current_scope_table);
                           current_scope_table = p;
                           offsets.pop();
                           //turn off boolean marking that we're out of the while loop
                           inside_while = false;
                       }
            | BREAK SC
                {
                    if (!inside_while)
                    {
                        errorUnexpectedBreak(yylineno);
                        exit(0);
                    }
                }
            | CONTINUE SC
                {
                    if (!inside_while)
                    {
                        errorUnexpectedContinue(yylineno);
                        exit(0);
                    }
                }
;
//marker M4
M4  :  IF LPAREN Exp RPAREN {
            if (($3)->type != TYPE_BOOL)
            {
                ($$)->err = true;
                ($$)->line_num = yylineno;
            }
            SymbolTable* new_table = new SymbolTable(current_scope_table);
            current_scope_table = new_table;
            offsets.push(offsets.top());
        }
//marker M5
M5  :  /*epsilon*/  %prec IF
        | ELSE
        {
            SymbolTable* new_scope_table = new SymbolTable(current_scope_table);
            current_scope_table = new_scope_table;
            offsets.push(offsets.top());
        }
        Statement{
            closeScope();
            SymbolTable* p = current_scope_table->getParent();
            delete(current_scope_table);
            current_scope_table = p;
            offsets.pop();
        }
        %prec ELSE

Call : ID LPAREN ExpList RPAREN
        {
            //check that function's name isn't "main", else error

            if (($1)->name == "main")
            {
                errorMismatch(yylineno);
                exit(0);
            }
            TableEntryFunc* f = (TableEntryFunc*)current_scope_table->getEntry(($1)->name);
            if (!f)
            {
                errorUndefFunc(yylineno, ($1)->name);
                exit(0);
            }

            //compare arguament list to declaration list
            if (!(f->compareArgumentTypes((dynamic_cast<ExpListNode*>($3))->exp_list)))
            {
                //set vector of types as strings to send as parameter to error function
                std::vector<std::string> types;
                for (std::vector<FormalDeclNode*>::const_iterator it = f->declaration_list->begin();
                     it != f->declaration_list->end(); it++)
                        {
                            if((*it)->type == TYPE_STRUCTID){
                                types.push_back("struct "+(*it)->s_name);
                            }
                             else
                                types.push_back(typeToString((*it)->type));
                        }
                errorPrototypeMismatch(yylineno, ($1)->name, types);
                exit(0);
            }
            CallNode* temp7 = new CallNode();
            temp7->return_type = f->return_type;
            $$ = temp7;
        }
        | ID LPAREN RPAREN
        {
            TableEntryFunc* f = (TableEntryFunc*)current_scope_table->getEntry(($1)->name);
            if (!f || (f->type != TYPE_FUNC)) //Fixed
            {
                errorUndefFunc(yylineno, ($1)->name);
                exit(0);
            }

            //should be an empty list of args
            if (f->declaration_list->size() != 0)
            {
                //set vector of types as strings to send as parameter to error function
                std::vector<std::string> types;
                for (std::vector<FormalDeclNode*>::const_iterator it = f->declaration_list->begin();
                                            it != f->declaration_list->end(); it++)
                         {
                             types.push_back(typeToString((*it)->type));
                         }
                errorPrototypeMismatch(yylineno, ($1)->name, types);
                exit(0);
            }
            CallNode* tempC= new CallNode();
            tempC->return_type = f->return_type;
            $$ = tempC;
        }
;

ExpList : Exp {
                // add the experssion to the expression list
                ExpListNode* temp5 = new ExpListNode();
                (temp5->exp_list)->push_back(dynamic_cast<ExpNode*>($1));
                $$ = temp5;
            }
          | Exp COMMA ExpList {
                ExpListNode* temp6 = new ExpListNode();
                temp6->exp_list = (dynamic_cast<ExpListNode*>($3))->exp_list;
                (temp6->exp_list)->push_back(dynamic_cast<ExpNode*>($1));
                $$ = temp6;
                //current list will be the list it derives with the exp is derives
            }
;

Type :   INT{
                TypeNode* t_node = new TypeNode();
                t_node->type = TYPE_INT;
                t_node->value = TYPE_INT;
                $$ = t_node;
             }
        | BYTE{
                TypeNode* t_node = new TypeNode();
                t_node->type = TYPE_BYTE;
                t_node->value = TYPE_BYTE;
                $$ = t_node;
              }
        | BOOL{
                TypeNode* t_node = new TypeNode();
                t_node->type = TYPE_BOOL;
                t_node->value = TYPE_BOOL;
                $$ = t_node;
              }
;

StructType : STRUCT ID ID{
                TableEntryStruct* IdVariable = (TableEntryStruct*)current_scope_table->getEntry(($2)->name);
                if(!IdVariable){
                    //the struct was never defined
                    errorUndefStruct(yylineno,($2)->name);
                    exit(0);
                }
                StructTypeNode* temp10 = new StructTypeNode($2->name);
                temp10->type = TYPE_STRUCTID;
                temp10->name = ($3)->name;
                temp10->size = IdVariable->size;
                $$ = temp10;
            }
;

ML :  { /* epsilon */
         //create new scope table for the scope
        SymbolTable* new_scope = new SymbolTable(current_scope_table);
        //the current scope is the new scope now
        current_scope_table = new_scope;
        //add the top value to the offsets stuck
        offsets.push(offsets.top());
};

Exp : LPAREN Exp RPAREN{
            $$->type = $2->type;
            $$->size = $2->size;
      }

      | Exp MUL Exp{
            //binops is defined on int and byte only (among the types that we are using in this project)
            if ((($1)->type != TYPE_INT && ($1)->type != TYPE_BYTE) || (($3)->type != TYPE_INT && ($3)->type != TYPE_BYTE)) {
                errorMismatch(yylineno);
                exit(0);
            }
            ($$)->size = 1; //both INT  and BYTE are size 1
            //the exp type is the type of the bigger of the $1 and $3 expressions
            if (($1)->type == TYPE_INT  || ($3)->type == TYPE_INT)
                ($$)->type = TYPE_INT;
            else
                ($$)->type = TYPE_BYTE;
        }
    | Exp DIV Exp{
            //binops is defined on int and byte only (among the types that we are using in this project)
            if ((($1)->type != TYPE_INT && ($1)->type != TYPE_BYTE) || (($3)->type != TYPE_INT && ($3)->type != TYPE_BYTE)) {
                errorMismatch(yylineno);
                exit(0);
            }
            ($$)->size = 1; //both INT  and BYTE are size 1
            //the exp type is the type of the bigger of the $1 and $3 expressions
            if (($1)->type == TYPE_INT  || ($3)->type == TYPE_INT)
                ($$)->type = TYPE_INT;
            else
                ($$)->type = TYPE_BYTE;
         }
       | Exp MINUS Exp{
            //binops is defined on int and byte only (among the types that we are using in this project)
            if ((($1)->type != TYPE_INT && ($1)->type != TYPE_BYTE) || (($3)->type != TYPE_INT && ($3)->type != TYPE_BYTE)) {
                errorMismatch(yylineno);
                exit(0);
            }
            ($$)->size = 1; //both INT  and BYTE are size 1
            //the exp type is the type of the bigger of the $1 and $3 expressions
            if (($1)->type == TYPE_INT  || ($3)->type == TYPE_INT)
                    ($$)->type = TYPE_INT;
            else
                ($$)->type = TYPE_BYTE;
        }
        | Exp PLUS Exp{
            //binops is defined on int and byte only (among the types that we are using in this project)
            if ((($1)->type != TYPE_INT && ($1)->type != TYPE_BYTE) || (($3)->type != TYPE_INT && ($3)->type != TYPE_BYTE)) {
                errorMismatch(yylineno);
                exit(0);
            }
            ($$)->size = 1; //both INT  and BYTE are size 1
            //the exp type is the type of the bigger of the $1 and $3 expressions
            if (($1)->type == TYPE_INT  || ($3)->type == TYPE_INT)
                ($$)->type = TYPE_INT;
            else
                ($$)->type = TYPE_BYTE;
        }
        | ID {
            //we need to check if this variable is defined in the upper or current scopes
            //if this variable is defined, we want to use it, therefore $1.type is not right, because we want the type of the variable, not the type of the token
            TableEntry* IdVariable = current_scope_table->getEntry(($1)->name);
            if(!IdVariable){
                //the variable was never defined
                errorUndef(yylineno,($1)->name);
                exit(0);
            }

            // the exp type and size is the variable type and size
            ExpNode* tempID = new ExpNode($1->name);
            if (IdVariable->type == TYPE_STRUCTID){
                    TableEntryStructType* sType = new TableEntryStructType();
                    sType  = dynamic_cast<TableEntryStructType*>(current_scope_table->getEntry(($1)->name));
                    if (!sType || sType->type != TYPE_STRUCTID)
                    { //no such structid
                        errorUndef(yylineno, ($1)->name);
                        exit(0);
                    }

                    TableEntryStruct* s = new TableEntryStruct();
                    s  = dynamic_cast<TableEntryStruct*>(current_scope_table->getEntry(sType->structName));
                    if (!s || s->type != TYPE_STRUCT)
                    { //no such struct
                        errorUndef(yylineno, sType->structName);
                        exit(0);
                    }

                    tempID->s_name = sType->structName;
            }
            tempID->type = IdVariable->type;
            tempID->size = IdVariable->size;
            tempID->name = IdVariable->name;
            $$ = tempID;
        }

      | ID PERIOD ID{
            //check if $1 is struct name and $3 is its field
            TableEntryStructType* sType = new TableEntryStructType();
            sType  = dynamic_cast<TableEntryStructType*>(current_scope_table->getEntry(($1)->name));
            if (!sType || sType->type != TYPE_STRUCTID)
            { //no such structid
                errorUndef(yylineno, ($1)->name);
                exit(0);
            }

            TableEntryStruct* s = new TableEntryStruct();
            s  = dynamic_cast<TableEntryStruct*>(current_scope_table->getEntry(sType->structName));
            if (!s || s->type != TYPE_STRUCT)
            { //no such struct
                errorUndef(yylineno, sType->structName);
                exit(0);
            }

            StructMemNode* field = new StructMemNode();
            field= s->getField(($3)->name);

            if (!field)
            {
                errorUndefStructMember(yylineno, ($1)->name);
                exit(0);
            }
            ExpNode* tempIDID = new ExpNode("");
            tempIDID->type = field->type;
            tempIDID->size = ($1)->size;
            $$ = tempIDID;
        }
        //DONE-------------------------------
      | Call {
            //if the exp derives a function call, it's value will be the return type
            ExpNode* tempCall = new ExpNode("");
            tempCall->type = (dynamic_cast<CallNode*>($1))->return_type;
            tempCall->reg = getAvailReg();
            //todo: debug
            if (tempCall->reg == NUM_OF_TEMP_REGS){
                cout<<"no temp regs aviliable in Call"<<endl;
                exit(0);
            }
            //the return value is stored in $v0 as requested
            CodeBuffer::instance().emit("move " + regToString(tempCall->reg) + ", $v0");
            //if the return value is bool habdle it now. it is forbidden to store boolean variables in tmp regs
            if ((dynamic_cast<CallNode*>($1))->return_type == TYPE_BOOL){
                // exp = f() (func_ans) - bool
                //save this line: "beq func_ans , 1 , (label)" in order to later perform backpatch to the lable
                std::vector<int> line_with_quad = CodeBuffer::makelist(CodeBuffer::instance().emit("beq " + regToString(tempCall->reg) + ", 1, "));
                CodeBuffer::instance().genLabel();                              //false:
                (tempCall)->falseList.push_back(CodeBuffer::instance().emit("j ")); //goto ___
                std:: string trueLabel = CodeBuffer::instance().genLabel();     //true:
                (tempCall)->trueList.push_back(CodeBuffer::instance().emit("j "));  //goto ___
                CodeBuffer::instance().bpatch(line_with_quad, trueLabel); //(label) = trueLabel
                returnTempReg(tempCall->reg); //we already used the return value , no need for this temp reg no more
                (tempCall)->reg = NUM_OF_TEMP_REGS;
            }
            $$ = tempCall;
        }
        //DONE--------------------------
      | NUM {
            ExpNode* tempE1 = new ExpNode(($1)->name);
            //exp type = num type = int
            tempE1->type = TYPE_INT;
            tempE1->size = 1; //Int size is 1
            tempE1->value = ($1)->name;
            tempE1->reg = getAvailReg();
            //put the num in temp reg for future calculations
            if (tempE1->reg == NUM_OF_TEMP_REGS) {
                //todo: debug
                cout<< "debug: out of regs in NUM"<< endl;
                exit(0);
            }
            CodeBuffer::instance.emit("li "+regToString(tempE1->reg)+", "+intToString(tempE1->value));
            $$ = tempE1;
        }
        //DONE-----------------------------
      | NUM B {
            const char * c = ((($1))->name).c_str();
            if (std::strtol(c, NULL, 0) > 255)
            {
                errorByteTooLarge(yylineno, (($1))->name);
                exit(0);
            }
            //exp type = num type = byte
            ExpNode* tempE2 = new ExpNode(($1)->name);
            tempE2->type = TYPE_BYTE;
            tempE2->size = 1; //byte size is 1
            tempE2->value = ($1)->name;
            //put the num in temp reg for future calaulations
            tempE2->reg = getAvailReg();
             if (tempE2->reg == NUM_OF_TEMP_REGS) {
                //todo: debug
                 cout<< "debug: out of regs in NUM B"<<endl;
                 exit(0);
             }
             CodeBuffer::instance.emit("li "+regToString(tempE1->reg)+", "+intToString(tempE1->value));
             $$ = tempE2;
          }
//TODO ==========================================
      | STRING{
            ExpNode* tempE3 = new ExpNode(($1)->name);
            //exp type = num type = string
            tempE3->type = TYPE_STRING;
            tempE3->size = 1; //string size is 1
            tempE3->value = ($1)->name;
            ($$)=tempE3;
        }
        //DONE---------------------
      | TRUE{
            //exp type = true type = bool
            ExpNode* tempE4 = new ExpNode(($1)->name);
            tempE4->type = TYPE_BOOL;
            tempE4->size = 1; //bool size is 1
            tempE4->value = ($1)->name;
            tempE4->reg = NUM_OF_TEMP_REGS;
            /*when we will no what supposed to happend (which code part should be running) when this exp is true,
             we will backpatch the address of the code to the empty space in the goto__ */
            tempE4->trueList.pushback(CodeBuffer::instance().emit("j ")); //goto ___
            //no false list, the exp is true therefor the code when he will jump to when the exp is false is irrelevent
            ($$)=tempE4;
        }
        //DONE--------------------
      | FALSE{
            ExpNode* tempE5 = new ExpNode(($1)->name);
            //exp type = false type = bool
            tempE5->type = TYPE_BOOL;
            tempE5->size = 1; //bool size is 1
            tempE5->value = ($1)->name;
            tempE5->reg = NUM_OF_TEMP_REGS;
            /*when we will no what supposed to happend (which code part should be running) when this exp is false,
             we will backpatch the address of the code to the empty space in the goto__ */
            tempE5->falseList.pushback(CodeBuffer::instance().emit("j ")); //goto ___
            //no true list, the exp is false therefor the code when he will jump to when the wxp is true is irrelevent
            ($$)=tempE5;
        }
        //DONE----------------------
      | NOT Exp {
            if(($2)->type != TYPE_BOOL){
                //not operator is valid only on bool variables
                errorMismatch(yylineno);
                exit(0);
            }
            ExpNode* tempEx5 = new ExpNode("");
            tempEx5->type = TYPE_BOOL;
            tempEx5->size = 1; //bool size is 1
            tempEx5->reg = NUM_OF_TEMP_REGS;
            //exp = not exp1 --> exp false list is exp1 true list. exp false list is exp1 true list.
            std::vector<int> tmpList = (tempEx5)->trueList;
            (tempEx5)->trueList = (dynamic_cast<ExpNode*>$2)->falseList;
            (tempEx5)->falseList = tmpList;
            $$=tempEx5;
          }
        //DONE-------------------------------
      | Exp AND LB Exp{
            if(($1)->type != TYPE_BOOL || ($3)->type != TYPE_BOOL){
                //and operator is valid only on bool variables
                errorMismatch(yylineno);
                exit(0);
            }
            ExpNode* tempEx4 = new ExpNode("");
            tempEx4->type = TYPE_BOOL;
            tempEx4->size = 1; //bool size is 1
            //exp = exp1 and (lable) exp2
            //if exp1 is true, goto label
            CodeBuffer::instance().bpatch((dynamic_cast<ExpNode*>$1))->trueList, (dynamic_cast<lbNode*>$3)->label);
            //if exp2 if true then go to the true lable of exp2
            (tempEx4)->trueList = (dynamic_cast<ExpNode*>$4)->trueList;
            //if exp1 if false goto the exp false lable. if exp2 if false goto the exp false lable.
            (tempEx4)->falseList = CodeBuffer::merge((dynamic_cast<ExpNode*>$1)->falseList,(dynamic_cast<ExpNode*>$4)->falseList);
            $$ = tempEx4;
        }
      //DONE-------------------------------
      | Exp OR LB Exp{
            if (($1)->type != TYPE_BOOL || ($3)->type != TYPE_BOOL){
            //or operator is valid only on bool variables
                errorMismatch(yylineno);
                exit(0);
            }
            ExpNode* tempEx3 = new ExpNode("");
            tempEx3->type = TYPE_BOOL;
            tempEx3->size = 1; //bool size is 1
            //exp = exp1 or (lable) exp2
            //if exp1 if false goto lable
            CodeBuffer::instance().bpatch((dynamic_cast<ExpNode*>$1)->falseList, (dynamic_cast<lbNode*>$3)->label);
            //if exp1 if true goto the exp true label, if exp2 is true goto the exp true lable.
            (tempEx3)->trueList = CodeBuffer::merge(dynamic_cast<ExpNode*>$1)->trueList,(dynamic_cast<ExpNode*>$4)->trueList);
            //if exp2 is false then goto the exp false lable
            (tempEx3)->falseList = (dynamic_cast<ExpNode*>$4)->falseList;
            $$ = tempEx3;
       }
      //DONE------------------------------
      | Exp EQUAL Exp{
            if ((($1)->type != TYPE_INT && ($1)->type != TYPE_BYTE) || (($3)->type != TYPE_BYTE && ($3)->type != TYPE_INT)){
                errorMismatch(yylineno);
                exit(0);
            }
            ExpNode* tempEx2 = new ExpNode("");
            tempEx2->type = TYPE_BOOL; // return type of relop operator is bool
            tempEx2->size = 1; //bool size is 1
            tempEx2->reg = NUM_OF_TEMP_REGS; //no temp reg yet
            // exp = exp1 == exp2
            //in buffer: beq exp1, exp2, ___ (true lable)
            //            ___(false lable)
            (tempEx2)->trueList.push_back(CodeBuffer::instance().emit("beq "+regToString((dynamic_cast<ExpNode*>$1)->reg)+", "+regToString((dynamic_cast<ExpNode*>$3)->reg)+", ");
            (tempEx2)->falseList.push_back(CodeBuffer::instance().emit("j ")); //if exp1 != exp2 goto___ (false lable)
            returnTempReg((dynamic_cast<ExpNode*>$1)->reg);
            returnTempReg((dynamic_cast<ExpNode*>$3)->reg);
            $$=tempEx2;
       }
       //DONE------------------------
        | Exp NOTEQUAL Exp{
            if ((($1)->type != TYPE_INT && ($1)->type != TYPE_BYTE) || (($3)->type != TYPE_BYTE && ($3)->type != TYPE_INT)){
                errorMismatch(yylineno);
                exit(0);
            }
            ExpNode* tempEx2 = new ExpNode("");
            tempEx2->type = TYPE_BOOL; // return type of relop operator is bool
            tempEx2->size = 1; //bool size is 1
            tempEx2->reg = NUM_OF_TEMP_REGS; //no temp reg yet
            // exp = exp1 != exp2
            //in buffer: bne exp1, exp2, ___ (true lable)
            //            ___(false lable)
            (tempEx2)->trueList.push_back(CodeBuffer::instance().emit("bne "+regToString((dynamic_cast<ExpNode*>$1)->reg)+", "+regToString((dynamic_cast<ExpNode*>$3)->reg)+", ");
            (tempEx2)->falseList.push_back(CodeBuffer::instance().emit("j ")); //if exp1 == exp2 goto___ (false lable)
            returnTempReg((dynamic_cast<ExpNode*>$1)->reg);
            returnTempReg((dynamic_cast<ExpNode*>$3)->reg);
            $$=tempEx2;
        }
        //DONE---------------------------
      | Exp BIGGER Exp{
        if ((($1)->type != TYPE_INT && ($1)->type != TYPE_BYTE) || (($3)->type != TYPE_BYTE && ($3)->type != TYPE_INT)){
            //and operator is valid only on numerical variables
            errorMismatch(yylineno);
            exit(0);
        }

        ExpNode* tempEx1 = new ExpNode("");
        tempEx1->type = TYPE_BOOL; // return type of relop operator is bool
        tempEx1->size = 1; //bool size is 1
        tempEx1->reg = NUM_OF_TEMP_REGS; //no temp reg yet
        // exp = exp1 > exp2
        //in buffer: bgt exp1, exp2, ___ (true lable)
        //            ___(false lable)
        if (($1)->type == TYPE_BYTE && ($2)->type != TYPE_BYTE) // compare between bytes
            (tempEx1)->trueList.push_back(CodeBuffer::instance().emit("bgtu "+regToString((dynamic_cast<ExpNode*>$1)->reg)+", "+regToString((dynamic_cast<ExpNode*>$3)->reg)+", ");
        else //regular comapare
            (tempEx1)->trueList.push_back(CodeBuffer::instance().emit("bgt "+regToString((dynamic_cast<ExpNode*>$1)->reg)+", "+regToString((dynamic_cast<ExpNode*>$3)->reg)+", ");
        (tempEx1)->falseList.push_back(CodeBuffer::instance().emit("j ")); //if exp1 == exp2 goto___ (false lable)
        returnTempReg((dynamic_cast<ExpNode*>$1)->reg);
        returnTempReg((dynamic_cast<ExpNode*>$3)->reg);
        $$ = tempEx1;
       }
       //DONE----------------------------------
        | Exp SMALLER Exp{
            if ((($1)->type != TYPE_INT && ($1)->type != TYPE_BYTE) || (($3)->type != TYPE_BYTE && ($3)->type != TYPE_INT)){
                //and operator is valid only on numerical variables
                errorMismatch(yylineno);
                exit(0);
            }

            ExpNode* tempEx1 = new ExpNode("");
            tempEx1->type = TYPE_BOOL; // return type of relop operator is bool
            tempEx1->size = 1; //bool size is 1
            tempEx1->reg = NUM_OF_TEMP_REGS; //no temp reg yet
            // exp = exp1 < exp2
            //in buffer: blt exp1, exp2, ___ (true lable)
            //            ___(false lable)
            if (($1)->type == TYPE_BYTE && ($2)->type != TYPE_BYTE) // compare between bytes
                (tempEx1)->trueList.push_back(CodeBuffer::instance().emit("bltu "+regToString((dynamic_cast<ExpNode*>$1)->reg)+", "+regToString((dynamic_cast<ExpNode*>$3)->reg)+", ");
            else //regular comapare
                (tempEx1)->trueList.push_back(CodeBuffer::instance().emit("blt "+regToString((dynamic_cast<ExpNode*>$1)->reg)+", "+regToString((dynamic_cast<ExpNode*>$3)->reg)+", ");
            (tempEx1)->falseList.push_back(CodeBuffer::instance().emit("j ")); //if exp1 == exp2 goto___ (false lable)
            returnTempReg((dynamic_cast<ExpNode*>$1)->reg);
            returnTempReg((dynamic_cast<ExpNode*>$3)->reg);
            $$ = tempEx1;
        }
        //DONE-------------------------------------
        | Exp SEQ Exp{
            if ((($1)->type != TYPE_INT && ($1)->type != TYPE_BYTE) || (($3)->type != TYPE_BYTE && ($3)->type != TYPE_INT)){
                //and operator is valid only on numerical variables
                errorMismatch(yylineno);
                exit(0);
            }

            ExpNode* tempEx1 = new ExpNode("");
            tempEx1->type = TYPE_BOOL; // return type of relop operator is bool
            tempEx1->size = 1; //bool size is 1
            tempEx1->reg = NUM_OF_TEMP_REGS; //no temp reg yet
            // exp = exp1 <= exp2
            //in buffer: ble exp1, exp2, ___ (true lable)
            //            ___(false lable)
            if (($1)->type == TYPE_BYTE && ($2)->type != TYPE_BYTE) // compare between bytes
            (tempEx1)->trueList.push_back(CodeBuffer::instance().emit("bleu "+regToString((dynamic_cast<ExpNode*>$1)->reg)+", "+regToString((dynamic_cast<ExpNode*>$3)->reg)+", ");
            else //regular comapare
            (tempEx1)->trueList.push_back(CodeBuffer::instance().emit("ble "+regToString((dynamic_cast<ExpNode*>$1)->reg)+", "+regToString((dynamic_cast<ExpNode*>$3)->reg)+", ");
            (tempEx1)->falseList.push_back(CodeBuffer::instance().emit("j ")); //if exp1 == exp2 goto___ (false lable)
            returnTempReg((dynamic_cast<ExpNode*>$1)->reg);
            returnTempReg((dynamic_cast<ExpNode*>$3)->reg);
            $$ = tempEx1;
        }
        //DONE-----------------------------------------
        | Exp BEQ Exp{
            if ((($1)->type != TYPE_INT && ($1)->type != TYPE_BYTE) || (($3)->type != TYPE_BYTE && ($3)->type != TYPE_INT)){
                //and operator is valid only on numerical variables
                errorMismatch(yylineno);
                exit(0);
            }

            ExpNode* tempEx1 = new ExpNode("");
            tempEx1->type = TYPE_BOOL; // return type of relop operator is bool
            tempEx1->size = 1; //bool size is 1
            tempEx1->reg = NUM_OF_TEMP_REGS; //no temp reg yet
            // exp = exp1 => exp2
            //in buffer: bge exp1, exp2, ___ (true lable)
            //            ___(false lable)
            if (($1)->type == TYPE_BYTE && ($2)->type != TYPE_BYTE) // compare between bytes
            (tempEx1)->trueList.push_back(CodeBuffer::instance().emit("bgeu "+regToString((dynamic_cast<ExpNode*>$1)->reg)+", "+regToString((dynamic_cast<ExpNode*>$3)->reg)+", ");
            else //regular comapare
            (tempEx1)->trueList.push_back(CodeBuffer::instance().emit("bge "+regToString((dynamic_cast<ExpNode*>$1)->reg)+", "+regToString((dynamic_cast<ExpNode*>$3)->reg)+", ");
            (tempEx1)->falseList.push_back(CodeBuffer::instance().emit("j ")); //if exp1 == exp2 goto___ (false lable)
            returnTempReg((dynamic_cast<ExpNode*>$1)->reg);
            returnTempReg((dynamic_cast<ExpNode*>$3)->reg);
            $$ = tempEx1;
        }
;

LB: {
    lbNode* Templb = new lbNode(CodeBuffer::instance().genLable());
    $$ = Templb;
};

%%

/*USER ROUTINES*/


void yyerror(std::string m)
{
    errorSyn(yylineno);
    exit(0);
}

int main() {
   //yydebug = 1; //todo: for debug
    SymbolTable* temp_table = new SymbolTable(NULL);
    current_scope_table = temp_table;
    offsets.push(0);
    FormalDeclNode* n = new FormalDeclNode();
    n->name = "";
    n->type = TYPE_STRING;
    n->size = 1;
    current_scope_table->insertFunctionEntry("print", TYPE_VOID);
    TableEntryFunc* f_print = (TableEntryFunc*)current_scope_table->getEntry("print");
    f_print->declaration_list->push_back(n);
    FormalDeclNode* n2 = new FormalDeclNode();
    n2->name = "";
    n2->type = TYPE_INT;
    n2->size = 1;
    current_scope_table->insertFunctionEntry("printi", TYPE_VOID);
    TableEntryFunc* f_printi = (TableEntryFunc*)current_scope_table->getEntry("printi");
    f_printi->declaration_list->push_back(n2);
    yyparse();
    int main_counter = 0;
    for (std::vector<TableEntry*>::const_iterator it = current_scope_table->scope_table->begin(); it != current_scope_table->scope_table->end(); it++)
    {
        if (((TableEntryFunc*)(*it))->type ==TYPE_FUNC)
        {
            if ((*it)->name == "main" && ((TableEntryFunc*)(*it))->return_type == TYPE_VOID && ((TableEntryFunc*)(*it))->declaration_list->size() == 0)
            {
                main_counter++;
            }
        }

    }
    if (main_counter != 1)
    {
        errorMainMissing();
        exit(0);
    }
    closeScope();
    delete(temp_table);
}


void printStructTypeHelp(const string& name, std::vector<StructMemNode*>* fields){
    std::vector<typeName>* Types = new std::vector<typeName>();
    std::vector<string>* Names = new std::vector<string>();
    for(std::vector<StructMemNode*>::reverse_iterator it = fields->rbegin();it!=fields->rend();it++){
        Types->push_back((*it)->type);
        Names->push_back((*it)->name);
    }
    printStructType(name, *(TypeVecToString(*Types)), *Names);
}

std::string typeToString(typeName type){
    switch (type){
        case(TYPE_BYTE) :
            return "BYTE";
        case(TYPE_BOOL) :
            return "BOOL";
        case(TYPE_INT) :
            return "INT";
        case(TYPE_STRING) :
            return "STRING";
        case(TYPE_STRUCT) :
            return "STRUCT";
        case(TYPE_STRUCTID) :
            return "STRUCTID";
        case(TYPE_VOID) :
            return "VOID";
    }
}

std::vector<string>* TypeVecToString(std::vector<typeName>& t_vec){
    std::vector<string>* s_vec = new std::vector<string>();

    for(int i=0; i< t_vec.size(); i++){
       s_vec->push_back(typeToString(t_vec[i]));
    }

    return s_vec;
}

std::vector<typeName>* declToTypes(std::vector<FormalDeclNode*>* decls){
    std::vector<typeName>* res = new std::vector<typeName>();
    for(std::vector<FormalDeclNode*>::const_iterator it = decls->begin(); it != decls->end(); it++){
        if (typeToString((*it)->type) == "STRUCTID")
        res->push_back((*it)->type);
    }
    return res;
}

std::vector<std::string>* declToStrings(std::vector<FormalDeclNode*>* decl)
{
    std::vector<std::string>* res = new std::vector<std::string>();
    for(std::vector<FormalDeclNode*>::const_iterator it = decl->begin(); it != decl->end(); ++it)
    {
        typeName type_temp = (*it)->type;
        if (typeToString(type_temp) != "STRUCTID")
            res->push_back(typeToString(type_temp));
        else
            res->push_back("struct "+(*it)->s_name);
    }
    return res;
}


void closeScope() {
    endScope();

    //for all arguments in the scope table, print them
    for (std::vector<TableEntry*>::const_iterator it = (current_scope_table->scope_table)->begin(); it != (current_scope_table->scope_table)->end(); it++) {
        if ((*it)->type == TYPE_FUNC) {
            output::printID((*it)->name, (*it)->offset,
                            makeFunctionType(typeToString(dynamic_cast<TableEntryFunc*>((*it))->return_type), *(declToStrings
                                                (((TableEntryFunc *) (*it))->declaration_list))));
        } else if ((*it)->type == TYPE_STRUCTID) {
            //note: "+" is string concatenation operator
            printID((*it)->name, (*it)->offset, ("struct " + ((TableEntryStructType *) (*it))->structName));
        } else if ((*it)->type == TYPE_STRUCT) {
            //do nothing
        } else {
            printID((*it)->name, (*it)->offset, typeToString((*it)->type));
        }
    }
        for (std::vector<TableEntry*>::const_iterator it2 = (current_scope_table->scope_table)->begin(); it2 != (current_scope_table->scope_table)->end(); it2++) {
            if ((*it2)->type != TYPE_STRUCT) {
                    //do nothing
             }
            else { // type is struct
                TableEntryStruct* structInfo = (TableEntryStruct*)(*it2);
                printStructTypeHelp(structInfo->name, structInfo->Fields->s_list);
            }
    }

}