//note: this is en exemple from the tutorial //todo: delete
%{
/*USER DECLERATIONS*/
#include <iostream>
#include "calc.h"
#include "symtable.h"
#include "output.hpp"

using namespace std;
int yylex();
void yyerro(const char*);

SymbolTable currentScopeTable;

//the offsets stack. the ith entry in the stack contains the offset from the beginning of the ith scope
//to the variable to be inserted next
std::stack<int> offsets;

%}
/*DECLERATIONS*/
%token VOID BYTE B BOOL STRUCT TRUE FALSE RETURN IF WHILE BREAK CONTINUE SC COMMA PERIOD ID NUM STRING NARELOP
%left AND OR LPAREN RPAREN LBRACE RBRASCE BINOP ARELOP
%right NOT ASSIGN
%nonassoc ELSE

%%
/*RULES*/
Program :   Structs Funcs
;
Funcs :   FuncsDecl Funcs
          | /*epsilon*/
;
FuncDecl : RetType ID LPAREN Formals RPAREN {
            /* todo: paudo code
             * check if function args are legal
             * add funcion to current scope
             * create new scop table and define it as the currentScopeTable
             * insert the top offset to the offset table
             * insert all arguments as an Entries in the current scope, while updating the offset (is Entry alredy defined, is alraedy implenemted in "insert" method
             */
            }
           LBRACE Statments RBRACE{
            /* todo: psaudo code:
             * call "endScope"
             * call a function that does all the things that we were askd to do in page 6
             * delete current scope and define "CurrentScopeTable" to be it's father
             */
           }
;

Structs :   StructsDecl Structs
            | /*epsilon*/
;

StructsDecl : STRUCT ID {
                /* todo: paudo code
               * add struct to current scope9while checking if the name is not belong to any other entry int he scope)
               */
              }
              LBRACE StructMemList RBRACE{
                /* create new scop table and define it as the currentScopeTable
                * insert the top offset to the offset table
                * insert all arguments as an Entries in the current scope, while updating the offset (is Entry alredy defined, is alraedy implenemted in "insert" method
                */
                }
              SC
;

RetType : Type {
                    //todo: $$.type = $1.type ???
            }
          | VOID {
                    //todo: $$.type = VOID ???
                 }
;
Formals : FormalsList
           | /*epsilon*/
;
FormalsList : FormalDecl
                | FurmalDecl COMMA FormalsList
;
FormalDecl : Type ID
            | StructType ID
;
StructMemList : StructMem
                | StructMem StructMemList
;
StructMem : Type ID SC
;
Statements : Statement
            | Statement Statements
;
Statement : LBRACE Statements RBRACE
            | Type ID SC
            | StructType ID SC
            | STRUCT ID LBRACE StructMemList RBRACE SC
            | Type ID ASSIGN Exp SC
            | StructType ID ASSIGN Exp SC
            | ID ASSIGN Exp SC
            | ID PERIOD ID ASSIGN Exp SC
            | Call SC
            | RETURN SC{
                //todo: get to the current function by the current scope, chack if it's return type is void
            }
            | RETURN Exp SC {
                /*todo: get to the current function by the current scope, chack if it's return type is eq the exp type
                        (it can also be byte if exp type is int - page 4 rule 12)
                 */
            }
            | IF LPAREN Exp RPAREN Statement
            | IF LPAREN Exp RPAREN Statement ELSE Statement
            | WHILE LPAREN Exp RPAREN Statement
            | BREAK SC
            | CONTINUE SC
;
Call : ID LPAREN ExpList RPAREN
        | ID LPAREN RPAREN
;
ExpList : Exp
          | Exp COMME ExpList;
;
Type :   INT
        | BYTE
        | BOOL
;
StructType : STRUCT ID
;
Exp : LPAREN Exp RPAREN
      | Exp BINOP Exp{
            //binops is defined on int and byte only (among the types that we are using in this project)
            if (($1.type != TYPE_INT && $1.type != TYPE_BYTE) || ($3.type != TYPE_INT && $3.type != TYPE_BYTE) {
                errorMismatch(yylineo);
                exit();
            }
            $$.size = 1; //both INT  and BYTE are size 1
            //the exp type is the type of the bigger of the $1 and $3 expressions
            if ($1.type == TYPE_INT || $2.type == TYPE_INT)
                $$.type = TYPE_INT;
            else
                $$.type = TYPE_BYTE;
        }

      | ID {
            //we need to check if this variable is defined in the upper or current scopes
            //if this variable is defined, we want to use it, therefore $1.type is not right, because we want the type of the variable, not the type of the token
            TableEntry* IdVariable = currentScopeTable->getEntry($1.name);
            if(IdVariable == nullptr){
                //the variable was never defined
                errorUndef(yylineno,$1.name);
                exit();
            }
            // the exp type and size is the variable type and size
            $$.type = IdVariable.type;
            $$.size = IdVariable.size;
        }

      | ID PERIOD ID{
            //we need to check if this variable is defined in the upper or current scopes
            //if this variable is defined, we want to use it, therefore $1.type is not right, because we want the type of the variable, not the type of the token
            TableEntry* IdVariable = currentScopeTable->getEntry($1.name); //todo: implement getEntry
            if(IdVariable == nullptr || IdVariable.StructType == nullptr){
            //the variable was never defined or it's type is not a struct type
                errorUndef(yylineno,$1.name);
                exit();
            }
            //todo: nonterminals class names diffrent than class names
            TableEntry Struct = currentScopeTable->getEntry(IdVariable.StructType); //get the struct variable (Aminal for exemple), shouldn't fail, because this is the type defenition of $1
            std::vector<structMem> StructFiledsList = Struct->getFieldList(); //get the list of the fileds of the struct (int age, string name, string furrColor) //todo: implement get list
                                                                              //(this is a list of variable defenitions, not variables)
            //todo: structMemList should be the type of  std::vector<structMem>
            //todo: structMem should have name field
            structMem field;
            //search for the suitiable filed in the list
            for(std::vector<structMem>::iterator it = StructFiledList.begin() ; *it != StructFiledList.end(); it++){
                if((*it).name == $2.name){
                    field = *it; //we found the wanted field
                    break;
                }
            }
            if (field == StructFiledList.end()){ //no such filed
                errorUndefStructMember(yylineo,$1.name);
                exit();
            }
            //else
            $$.type = field.type;
            $$.type = $$.size;
        }

      | Call
      | NUM
      | NUM B
      | STRING
      | TRUE
      | FALSE
      | NOT Exp
      | Exp AND Exp
      | Exp OR Exp
      | Exp RELOP Exp
;


%%

/*USER ROUTINES*/
void yyerror //todo: delete?
        (const char*) { cout << "syntax error" << endl; }


int main() {
    //todo: add "currentScopeTable" - global
    //todo: add "offsetsTable" vector -global
    //todo: add print and printi to the scope (this is the global scope) - page 4
    yyparse();
    //todo: check if main is missing
    //todo: delete global scope
}