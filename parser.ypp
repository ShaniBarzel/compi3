%{
/*USER DECLERATIONS*/
//#define YYERROR_VERBOSE 1 //todo: for degbug
#define YYDEBUG 1 //todo: for debug
#include <iostream>
#include "symtable.h"
#include "attributes.h"
#include "output.hpp"
#include <stack>
#include <cstdlib> //for exit
#include "bp.hpp"
using namespace output; //errors defined inside the neamespace

extern int yylex();
void yyerror(std::string);
extern int yylineno;

//this will be initiated to the global scope. will be pointer to the current scope in current point in time.
SymbolTable* current_scope_table;

//the offsets stack. the ith entry in the stack contains the offset from the beginning of the ith scope
//to the variable to be inserted next
std::stack<int> offsets;
std::stack<int> frame_offsets;

//a boolean for knowing if we're inside a while loop
bool inside_while = false;
//a boolean for knowing weather main is defined
bool main_def = false;

//implemented at the end of the file
void printStructTypeHelp(const string& name, std::vector<StructMemNode*>* fields);
std::vector<string>* TypeVecToString(std::vector<typeName>& t_vec);
std::string typeToString(typeName type);
void closeScope();
std::vector<typeName>* declToTypes(std::vector<FormalDeclNode*> decls);
std::vector<bool> AvailRegs(NONE,true); //init all register to be free to use
TempReg getAvailReg();
std::string intToString(int num);
std::string regToString(TempReg r_num);
void returnTempReg(TempReg ret);
void freeUpSpaceStack(int size);
void storeVariable(TempReg reg, int offset, int size);
void evaluateBoolean(ExpNode* exp);

%}
/*DECLERATIONS*/
%token VOID
%token INT
%token BYTE
%token B
%token BOOL
%token STRUCT
%token FALSE
%token TRUE
%token RETURN
%token WHILE
%token BREAK
%token CONTINUE
%token SC
%token COMMA
%token PERIOD
%token ID
%token NUM
%token STRING
%left LPAREN RPAREN LBRACE RBRACE
%right NOT ASSIGN
%left AND
%left OR
%nonassoc SMALLER BIGGER BEQ SEQ
%left EQUAL NOTEQUAL
%left PLUS MINUS
%left MUL DIV
%nonassoc IF
%nonassoc ELSE

%%
/*RULES*/


//no semantics needed
Program :  Structs Funcs{

}
;

//no semantics needed
Funcs :   FuncDecl Funcs
| /*epsilon*/
;

FuncDecl :  M1 LBRACE Statements RBRACE{
        //CodeBuffer::instance().printCodeBuffer(); //debug
        //*rach*
        //CodeBuffer::instance().bpatch(*(dynamic_cast<StatementsNode*>($3))->returnList, CodeBuffer::instance().genLabel());
        FuncDeclNode* temp1 = new FuncDeclNode();
        temp1->type = TYPE_FUNC;
        temp1->return_type = ($1)->type; //passed from marker
        $$ = temp1;
        //this function does all the things we were askd to do in page 6 when closing a scope. see function ducomentation for more details
        //closeScope(); //shani4 - was not in comment
        //return the current scope to be the outer scope
        SymbolTable* parent = current_scope_table->getParent();
        delete(current_scope_table);
        current_scope_table = parent;
        //back to the outer scope pffset
        offsets.pop();
        frame_offsets.pop(); //s only place we should do this. only when a function scope get closed
        if (($1)->name == "main") {  //exit label is for future use
            CodeBuffer::instance().emit("exit:");
            CodeBuffer::instance().emit("move $sp, $fp"); //return the stuck pinter to the frame poiter to earase frame from stuck //shani it was in comment
            CodeBuffer::instance().bpatch(*(dynamic_cast<StatementsNode*>($3)->returnList),"exit"); //shani: was missing //shani: statement has no nextlist rach92 changed to returnList
            CodeBuffer::instance().emit("li $v0, 10"); //10 is the exit syscall number
            CodeBuffer::instance().emit("syscall"); //call syscall number 10
            CodeBuffer::instance().emit(".end main");//shani
        } else {
            CodeBuffer::instance().emit((($1)->name)+"_exit:");//shani - make label for the end of the function
            CodeBuffer::instance().bpatch(*(dynamic_cast<StatementsNode*>($3)->returnList),($1)->name+"_exit");//shani rach92 changed to return list
            CodeBuffer::instance().emit("move $sp, $fp"); //return the stuck pinter to the frame poiter to earase frame from stuck //shani it was in comment
            CodeBuffer::instance().emit("jr $ra"); //jump to the adress in the ra register (return address)
            CodeBuffer::instance().emit(".end "+($1)->name);//shani
        }
}
;

/* marker 1 */
M1 : RetType ID LPAREN Formals RPAREN {
            //CodeBuffer::instance().printCodeBuffer(); //debug
            //to pass return typeto funcDecl
            ($$)->type = ($1)->type;
            ($$)->name = ($2)->name;//*rach*
            int ParamFrOffset = 0; //sn
            //try to insert to the current symbol table
            if (!(current_scope_table->insertFunctionEntry(($2)->name, ($1)->type,ParamFrOffset))) //sn
            {
                //already exist function with this name
                errorDef(yylineno,($2)->name);
                exit(0);
            }

            TableEntryFunc* f = new TableEntryFunc();
            f = dynamic_cast<TableEntryFunc*>(current_scope_table->getEntry(($2)->name));

            //create new scope table for function scope
            SymbolTable* new_func_scope = new SymbolTable(current_scope_table);
            //the current scope is the function scope now
            current_scope_table = new_func_scope;
            //add the top value to the offsets stuck
            offsets.push(offsets.top());
            frame_offsets.push(frame_offsets.top()); //sn

            int ParamOffset = offsets.top();//sn
            f->offset = ParamOffset;
            f->f_offset = frame_offsets.top(); //shani3 it was 0
            int vars_frame_offset =0;
            if (!($4->size == -1)){ //if the parameters list is not empty
                for(std::vector<FormalDeclNode*>::reverse_iterator it = (dynamic_cast<FormalsNode*>($4))->list->dec_list->rbegin(); (*it) && it != (dynamic_cast<FormalsNode*>($4))->list->dec_list->rend(); it++){
                    /*function aguments are treated as outer scope declered, there for, thire offset's are smaller than the function scope offset.
                    specipicaly, the "decleration" order in the outer scope is from the right variable in the agruments list, to the right. */
                    ParamOffset = ParamOffset - (*it)->size;
                        //shani3 +shani4 - we want to pus the struct in offset of it's size to make room for it's fields, but we dont want to do it in reguler vars
                    if((*it)->type != TYPE_STRUCTID){
                        if (!(current_scope_table->insertVariableEntry((*it)->name ,(*it)->type , ParamOffset, vars_frame_offset )))
                        {
                            //there is already a variable with the parameter's name
                            errorDef(yylineno, (*it)->name);
                            exit(0);
                        }
                        vars_frame_offset = vars_frame_offset - (*it)->size;  //reguler var- after insertion
                    }
                    else{ //arg type is struct id
                        vars_frame_offset = vars_frame_offset - (*it)->size +1; //struect var - before insertion //shani5 iadded +1
                        if (!(current_scope_table->insertStructTypeEntry( (*it)->name ,(*it)->s_name ,(*it)->type , (*it)->size,ParamOffset, vars_frame_offset))) //shani3 var_frame_offset was ParamFrOffset
                        {
                                //there is already a variable with the parameter's name
                                errorDef(yylineno,(*it)->name);
                                exit(0);
                        }
                        vars_frame_offset = vars_frame_offset - 1;  //shani6 - in video

                    }
                    f->declaration_list->push_back(*it);

                }
            }
            //emits appropriate code for main function declaration
            //making frame pointer to point to the stack pointer where the frame of main function should be placed
            if ((($2)->name == "main")) {
                CodeBuffer::instance().emit(".globl main");/*rach*/
                CodeBuffer::instance().emit(".ent main");//shani
                CodeBuffer::instance().emit("main:");/*rach*/
                CodeBuffer::instance().emit("move $fp, $sp");
               // CodeBuffer::instance().emit("subu $fp, $fp, 4"); //shani - no need, we spoke about it rach92 yes we do

                //emits code for regular function declaration
                //here we simply need to print the lable of the function name as the current fp points to the functions' frame already
            }else {
                std::string func_label="_" + ($2)->name;//shani
                CodeBuffer::instance().emit(".globl "+func_label);//shani
                CodeBuffer::instance().emit(".ent "+func_label);//shani
                CodeBuffer::instance().emit(func_label + ":");
                //CodeBuffer::instance().emit("move $fp, $sp"); //shani: was in comment and at the wrong place  rach92 put in comment as we agreed
            }
};

//no semantic needed
Structs :   StructsDecl Structs
        | /*epsilon*/
;

StructsDecl :  M2 RBRACE SC{
        //CodeBuffer::instance().printCodeBuffer(); //debug
        StructsDeclNode* temp9 = new StructsDeclNode();
        temp9->name = ($1)->name;
        temp9->size = ($1)->size;
        temp9->s_mem_list = (dynamic_cast<StructsDeclNode*>($1))->s_mem_list;
        $$ = temp9;
        SymbolTable* parent = current_scope_table->getParent();
        delete(current_scope_table);
        current_scope_table = parent;
        offsets.pop();

        //insert struct entry to the current scope
        current_scope_table->insertStructEntry(temp9->name, TYPE_STRUCT,temp9->s_mem_list,temp9->size);
};

// marker 2
M2 : STRUCT ID LBRACE StructMemList{
        // CodeBuffer::instance().printCodeBuffer(); //debug
        StructsDeclNode* temp8 = new StructsDeclNode();
        temp8->name = ($2)->name;
        temp8->type = ($1)->type;
        //insertion to current scope's table
        if (!(current_scope_table->insertStructEntry(($2)->name, TYPE_STRUCT,NULL,0))){
            // id already defined
            errorDef(yylineno - 1 - (dynamic_cast<StructMemListNode*>($4))->s_list->size(), (($2)->name));
            exit(0);
        }

        //note: there is no need to save the struct in the stuck, because it saves no data.


        std::vector<StructMemNode*>* fields_list = new std::vector<StructMemNode*>();
        fields_list = (dynamic_cast<StructMemListNode*>($4))->s_list;

        StructMemListNode* dec_fields_list = new StructMemListNode();

        current_scope_table->scope_table->pop_back();
        //create new scope table for the scope defined by the struct
        SymbolTable* new_scope_table = new SymbolTable(current_scope_table);
        current_scope_table = new_scope_table;
        //insert the new scope's offset to the offsets stack
        offsets.push(offsets.top());

        //the updating offset of the fields in the struct
        int current_offset = offsets.top();
        int current_f_offset = frame_offsets.top();
        int relative_offset = 0;
        int size = 0;
        //saving a reference to "fields list" field of the struct defined
        //iterating over the fields list of the struct
        for (std::vector<StructMemNode*>::const_iterator it = fields_list->begin(); it != fields_list->end(); it++){
            (*it)->relative_offset = relative_offset;
            relative_offset += (*it)->size;
            //insert the field as a table entry of the current scope table
            if (!(current_scope_table->insertVariableEntry((*it)->name, (*it)->type, current_offset,current_offset))){ //sn
                // id already defined
                errorDef(yylineno, (*it)->name);
                exit(0);
            }
            //insert field to s_mem_list of the StructTypeDecNode
            dec_fields_list->s_list->push_back(*it);
            //increment current offset by the current field's size //shani4: these two lines was before the insertion
            current_offset += (*it)->size;
            size += (*it)->size;
        }
        temp8->size = size;
        temp8->s_mem_list = dec_fields_list;
        $$ = temp8;
};


StructMemList : StructMem {
            //CodeBuffer::instance().printCodeBuffer(); //debug
            StructMemListNode* temp5 = new StructMemListNode();
            StructMemNode* temp5_1 = new StructMemNode();
            temp5_1 = dynamic_cast<StructMemNode*>($1);
            for (std::vector<StructMemNode*>::const_iterator it = temp5->s_list->begin(); it!=temp5->s_list->end(); ++it){
                if ((*it)->name == temp5_1->name){
                    errorDef(($1)->line_num, (*it)->name);
                    exit(0);
                }
            }
            std::vector<StructMemNode*>::iterator it = temp5->s_list->begin();
            (temp5->s_list)->insert(it, temp5_1);
            temp5->line_num = ($1)->line_num;
            temp5->lineNumberStart = ($1)->line_num - ($1)->size;
            $$ = temp5;
         }

        | StructMem StructMemList{
                StructMemListNode* temp6 = new StructMemListNode();
                StructMemNode* temp6_1 = new StructMemNode();
                temp6_1 = dynamic_cast<StructMemNode*>($1);
                StructMemListNode* temp6_2 = new StructMemListNode();
                temp6_2 = dynamic_cast<StructMemListNode*>($2);
                temp6->s_list = temp6_2->s_list;
                std::vector<StructMemNode*>::iterator it = temp6->s_list->begin();
                (temp6->s_list)->insert(it, temp6_1); //shani4: it was push_back. stuct fields was in the wrong order
                $$ = temp6;
} ;

StructMem : Type ID SC{
            //no data will be saved in this variable, it is only represents name of the field therefor no need to save it in the stuck
            StructMemNode* temp7 = new StructMemNode();
            temp7->type = ($1)->type;
            temp7->size = 1;
            temp7->name = ($2)->name;
            temp7->line_num = yylineno;
            $$ = temp7;
};

RetType : Type {
            RetTypeNode* rt_node = new RetTypeNode();
            rt_node->type = $1->type;
            $$ = rt_node;
        }
        | VOID {
            RetTypeNode* rt_node = new RetTypeNode();
            rt_node->type = TYPE_VOID;
            $$ = rt_node;
 } ;

Formals : FormalsList {
            FormalsNode* temp2 = new FormalsNode();
            (temp2->list)->dec_list = (dynamic_cast<FormalsListNode*>($1))->dec_list;
            $$ = temp2;
        }
        |/*epsilon*/ {
            FormalsNode* tempF = new FormalsNode();
            tempF->size = -1;
            $$ = tempF;
};

FormalsList : FormalDecl {
            FormalsListNode* temp3 = new FormalsListNode();
            (temp3->dec_list)->push_back(dynamic_cast<FormalDeclNode*>($1));
            $$ = temp3;
        }
        | FormalDecl COMMA FormalsList{
            FormalsListNode* temp4 = new FormalsListNode();
            temp4->dec_list = (dynamic_cast<FormalsListNode*>($3))->dec_list;
            (temp4->dec_list)->push_back(dynamic_cast<FormalDeclNode*>($1));
            $$ = temp4;
};

 FormalDecl : Type ID {
                FormalDeclNode* new_node = new FormalDeclNode();
                new_node->type = ($1)->type;
                new_node->name = ($2)->name;
                new_node->size =1;
                $$ = new_node;
        }
        | StructType  {
            FormalDeclNode* new_node = new FormalDeclNode();
            new_node->type = TYPE_STRUCTID;
            new_node->name = ($1)->name;
            new_node->size = ($1)->size;
            new_node->s_name = (dynamic_cast<StructTypeNode*>($1))->structName;
            $$ = new_node;
};

        //no semantics needed
Statements : Statement{
            StatementsNode* new_node = new StatementsNode();
           *(new_node->breakList) = *(dynamic_cast<StatementNode*>($1)->breakList); //shani6 was missing dereferences
            *(new_node->returnList) = *(dynamic_cast<StatementNode*>($1)->returnList); //shani6 was missing dereferences
            *(new_node->nextList) = *(dynamic_cast<StatementNode*>($1)->nextList); //shani8
            $$ = new_node;
        }
        | Statement Statements{
                StatementsNode* new_node = new StatementsNode();
                *(new_node->breakList) = CodeBuffer::merge(*(dynamic_cast<StatementNode*>($1)->breakList), *(dynamic_cast<StatementsNode*>($2)->breakList));
                *(new_node->returnList) = CodeBuffer::merge(*(dynamic_cast<StatementNode*>($1)->returnList), *(dynamic_cast<StatementsNode*>($2)->returnList));
                *(new_node->nextList) = CodeBuffer::merge(*(dynamic_cast<StatementNode*>($1)->nextList), *(dynamic_cast<StatementsNode*>($2)->nextList)); //shani8

                $$ = new_node;
        }
        ;

Statement : LBRACE ML Statements RBRACE
        {
             //this function does all the things we were asked to do in page 6 when closing a scope. see function ducomentation for more details
             //closeScope(); //shani3 was not in error
            //return the current scope to be the outer scope
            SymbolTable* parent = current_scope_table->getParent();
            delete(current_scope_table);
            current_scope_table = parent;
            //back to the outer scope offset
            offsets.pop();
            StatementNode* tempSt = new StatementNode();
            *(tempSt->breakList) = *((dynamic_cast<StatementsNode*>($3))->breakList);
            *(tempSt->returnList) = *((dynamic_cast<StatementsNode*>($3))->returnList);
             *(tempSt->nextList) = *((dynamic_cast<StatementsNode*>($3))->nextList); //shani8
            $$=tempSt;
        }
        | Type ID SC{
            int offset = offsets.top();
            int frame_offset = frame_offsets.top();
            frame_offsets.pop(); //sn
            offsets.pop();
            if (!(current_scope_table->insertVariableEntry(($2)->name,($1)->type,offset,frame_offset+1))){
                // Id already defined
                errorDef(yylineno,($2)->name);
                exit(0);
            }
            offsets.push(offset+1); //update offset
            frame_offsets.push(frame_offset+1);//sn
            //free up 1 cell space on stack for future storage of data in ID
            freeUpSpaceStack(1);
            StatementNode* tempSt4 = new StatementNode();
            $$=tempSt4;
         }
        | StructType SC {
                int offset = offsets.top();
                int frame_offset = frame_offsets.top();
                frame_offsets.pop();//sn
                offsets.pop();
                if (!(current_scope_table->insertStructTypeEntry(($1)->name, (dynamic_cast<StructTypeNode*>($1))->structName,TYPE_STRUCTID,$1->size,offset,frame_offset+1))){ //shani 5
                    // Id already defined
                    errorDef(yylineno,($1)->name);
                    exit(0);
                }
                offsets.push(offset+($1)->size); //update offset
                frame_offsets.push(frame_offset+($1)->size); //sn
                StatementNode* tempSt5 = new StatementNode();
                $$=tempSt5;
        }

        | StructsDecl

        | Type ID ASSIGN Exp SC{
            int offset = offsets.top();
            offsets.pop();
            int frame_offset = frame_offsets.top() ;
            frame_offsets.pop();
            if (!(current_scope_table->insertVariableEntry(($2)->name,($1)->type,offset,frame_offset+1))){
                // Id already defined
                errorDef(yylineno,($2)->name);
                exit(0);
            }
            offsets.push(offset+1); //update offset
            frame_offsets.push(frame_offset+1);//sn
            if (($4)->type != ($1)->type){
                // exp is not the same type as id
                if ((($4)->type != TYPE_BYTE) || (($1)->type != TYPE_INT)){ // assignment of byte to int is ok
                    errorMismatch(yylineno);
                    exit(0);
                }
            }

            if (($4)->type == TYPE_BOOL) {
                 evaluateBoolean(dynamic_cast<ExpNode*>($4));
            }
            freeUpSpaceStack(1); // subu $sw, $sw, 4
            TempReg expReg =($4)->reg;
            CodeBuffer::instance().emit("sw " + regToString(expReg) + ", ($sp)");
            //free up reg
            returnTempReg(expReg);
            //set reg to none
            ($4)->reg = NONE;

            StatementNode* tempSt6 = new StatementNode();
            $$=tempSt6;
        }
        | StructType ASSIGN Exp SC {
                if (($3)->type != TYPE_STRUCTID){
                    // exp is not structType type
                    errorMismatch(yylineno);
                    exit(0);
                }
                StructTypeNode* temp11 = new StructTypeNode("");
                temp11=dynamic_cast<StructTypeNode*>($1);
                if ((dynamic_cast<ExpNode*>($3))->s_name != temp11->structName){ //shani6: was (dynamic_cast<StrucTypeNode*>($3))->structName. yet $3 is coming from expNode. we cannot cast it to anything other then exp because we did "new ExpNode" in the rule code
                    // exp is not the same structType type
                    errorMismatch(yylineno);
                    exit(0);
                }
                int offset = offsets.top();
                offsets.pop();
                int frame_offset = frame_offsets.top();
                frame_offsets.pop();//sn
                if (!(current_scope_table->insertStructTypeEntry(temp11->name, temp11->structName,TYPE_STRUCTID,temp11->size,offset,frame_offset+1))){ //shani5
                    // Id already defined
                    errorDef(yylineno,($1)->name);
                    exit(0);
                }
                offsets.push(offset+($1)->size); //update offset
                frame_offsets.push(frame_offset+($1)->size);//sn
                //assignment to struct
                TempReg dest_reg = getAvailReg();
                TempReg temp_reg = getAvailReg();
                TableEntryStructType* entryS = dynamic_cast<TableEntryStructType*>(current_scope_table->getEntry(($3)->name));
                string dest_reg_s = regToString(dest_reg);
                int s_frame_offset = entryS->f_offset;
                //shani9 - all loop changed
                //get to the start of the source struct in the stuck by "fp + struct offset"
                CodeBuffer::instance().emit("subu " + dest_reg_s + ", $fp, " + intToString(4*(s_frame_offset)));
                //copy all fields of source struct to dest struct fields
                for (int i = 0; i < entryS->size; i++ ) {
                    CodeBuffer::instance().emit("lw " + regToString(temp_reg) + ", ("+ dest_reg_s +")"); //copy from stuct to temp reg
                    CodeBuffer::instance().emit("subu $sp ,$sp,  4"); //make place
                    CodeBuffer::instance().emit("sw " + regToString(temp_reg) + ", ($sp)");//store the fieled value - was shani4: $sp instead of ($sp) //shani7: changed to -4 instead of --x($fp)
                    CodeBuffer::instance().emit("subu "+dest_reg_s+", "+dest_reg_s+", 4"); //get to the next field in the copied struct
                }
                //free up regs
                returnTempReg(dest_reg);
                returnTempReg(temp_reg);
                dynamic_cast<ExpNode*>($3)->reg = NONE;
                returnTempReg(dynamic_cast<ExpNode*>($3)->reg);
                StatementNode* tempSt7 = new StatementNode();
                $$=tempSt7;
        }
        | ID ASSIGN Exp SC{
                TableEntry* entry = current_scope_table->getEntry(($1)->name);
                if (!entry || entry->type == TYPE_FUNC || entry->type == TYPE_STRUCT){
                    errorUndef(yylineno, ($1)->name);
                    exit(0);
                }

                //handle if struct<id>'s assignment
                if (entry->type == TYPE_STRUCTID && ($3)->type == TYPE_STRUCTID)
                {
                    TableEntryStructType* entryS = dynamic_cast<TableEntryStructType*>(current_scope_table->getEntry(($3)->name));
                    if (!entryS)
                    {
                        errorUndef(yylineno, ($3)->name);
                        exit(0);
                    }
                    if (entryS->structName != (dynamic_cast<TableEntryStructType*>(entry))->structName)
                    {
                        errorMismatch(yylineno);
                        exit(0);
                    }
                }

                //check if valid assignment
                else if (($3)->type != entry->type /*|| ($3)->size != entry->size*/)

                {
                    //check if not a byte to int assignment
                    if (!(($3)->type == TYPE_BYTE && entry->type == TYPE_INT))
                    {
                        errorMismatch(yylineno);
                        exit(0);
                    }
                }

                //check if type of var entry is byte and
                const char * c = ((dynamic_cast<ExpNode*>($3))->value).c_str();
                if (entry->type == TYPE_BYTE && std::strtol(c, NULL, 0) > 255)
                {
                    errorByteTooLarge(yylineno, (dynamic_cast<ExpNode*>($3))->value);
                    exit(0);
                }

                if (($3)->type == TYPE_BOOL) {
                    evaluateBoolean(dynamic_cast<ExpNode*>($3));
                }else if(($3)->type == TYPE_STRUCTID){//shani4 : else if was missing- all code inside else if was missing
                     TableEntryStructType* entryS = dynamic_cast<TableEntryStructType*>(current_scope_table->getEntry(($3)->name));
                    //assignment to struct
                    TempReg dest_reg = getAvailReg();
                    TempReg temp_reg = getAvailReg();
                    string dest_reg_s = regToString(dest_reg);
                    int s_frame_offset = entryS->f_offset;
                    int d_frame_offset= entry->f_offset;
                    int iterator_offset = d_frame_offset;
                    //get to the start of the source struct in the stuck by "fp + struct offset"
                    CodeBuffer::instance().emit("subu " + dest_reg_s + ", $fp, " + intToString(4*(s_frame_offset)));
                    //copy all fields of source struct to dest struct fields
                    for (int i = 0; i < entryS->size; i++ ) {
                        CodeBuffer::instance().emit("lw " + regToString(temp_reg) + ", ("+ dest_reg_s +")"); //copy from stuct to temp reg
                        CodeBuffer::instance().emit("sw " + regToString(temp_reg) + ", "+ intToString(-4*(iterator_offset))+"($fp)");//store the fieled value - was shani4: $sp instead of ($sp) //shani7: changed to -4 instead of --x($fp)
                        CodeBuffer::instance().emit("subu "+dest_reg_s+", "+dest_reg_s+", 4"); //get to the next field in the copied struct
                        iterator_offset ++;
                    }
                    //free up regs
                    returnTempReg(dest_reg);
                    returnTempReg(temp_reg);
                }else{ //shani2 else was missing
                     //store id value (currently in temp register) in stuck //sn to frame offset
                     CodeBuffer::instance().emit("sw " + regToString((dynamic_cast<ExpNode*>($3))->reg) + ", " + intToString(-4*(entry->f_offset)) + "($fp)");   //rach1 changed f_offset to offset //shani2- why? when it comes to assembly code, offset is always the frame offset
                }    //set reg of exp to be none
                returnTempReg(($3)->reg);
                ($3)->reg = NONE;
                StatementNode* tempSt8 = new StatementNode();
                $$=tempSt8;
            }

        | ID PERIOD ID ASSIGN Exp SC{
                //check if $1 is struct name and $3 is its field
                TableEntryStructType* sType = new TableEntryStructType();
                sType  = dynamic_cast<TableEntryStructType*>(current_scope_table->getEntry(($1)->name));
                if (!sType || sType->type != TYPE_STRUCTID)
                { //no such structid
                    errorUndef(yylineno, ($1)->name);
                    exit(0);
                }

                TableEntryStruct* s = new TableEntryStruct();
                s  = dynamic_cast<TableEntryStruct*>(current_scope_table->getEntry(sType->structName));
                if (!s || s->type != TYPE_STRUCT)
                { //no such struct
                    errorUndef(yylineno, ($1)->name);
                    exit(0);
                }

                StructMemNode* field = new StructMemNode();
                field= s->getField(($3)->name);

                if (!field)
                {
                    errorUndefStructMember(yylineno, ($1)->name);
                    exit(0);
                }
                //check types assignment match
                if (field->type != ($5)->type)
                {
                    if (!(($5)->type == TYPE_BYTE && field->type == TYPE_INT))
                    {
                        errorMismatch(yylineno);
                        exit(0);
                    }
                }

                const char* c = ((dynamic_cast<ExpNode*>($5))->value).c_str();
                if (($5)->type == TYPE_BYTE && std::strtol(c, NULL, 0) > 255) {
                    errorByteTooLarge(yylineno, (dynamic_cast<ExpNode *>($5))->value);
                    exit(0);

                }
                if (($5)->type == TYPE_BOOL) {
                    evaluateBoolean(dynamic_cast<ExpNode*>($5));
                }
                int field_offset = 4*(sType->f_offset +field->relative_offset); //sn
                //we wil have to go to the *field* storage in the stuck, means, find the offset of the struct in the stuct and add the field "relative offset" (i added it ) to get to the field offset
                CodeBuffer::instance().emit("sw " + regToString((dynamic_cast<ExpNode*>($5))->reg) + ", " + intToString(-field_offset) + "($fp)");

                //set reg of exp to be none
                returnTempReg(($5)->reg);
                ($5)->reg = NONE;
                StatementNode* tempSt9 = new StatementNode();
                $$=tempSt9;
        }
        | Call SC
                {
                  //free call's reg
                   // returnTempReg($1->reg);//shani - call has no temp reg
                    StatementNode* tempSt9 = new StatementNode();
                    $$=tempSt9;
        }

        | RETURN SC{
                //get current function scope
                TableEntryFunc* current_function = current_scope_table->getLastFunctionEntry();

                //error if return type of the entry isn't void
                if (current_function->return_type != TYPE_VOID)
                {
                    errorMismatch(yylineno);
                    exit(0);
                }
                StatementNode* tempSt10 = new StatementNode();
                //we want the return list of statement to include only "jump" instruction
                //*(tempSt10->returnList) = CodeBuffer::makelist(CodeBuffer::instance().emit("j ")); //shani - caused sigfault
                (tempSt10->returnList)->push_back(CodeBuffer::instance().emit("j "));
                $$=tempSt10;

        }
        | RETURN Exp SC {
                TableEntryFunc* current_function = current_scope_table->getLastFunctionEntry();
                //check if Exp type can be assigned to the functions' return type
                if (current_function->return_type != ($2)->type && !(current_function->return_type == TYPE_INT && ($2)->type == TYPE_BYTE))
                {
                    errorMismatch(yylineno);
                    exit(0);
                }
                if (($2)->type == TYPE_BOOL) {
                      evaluateBoolean(dynamic_cast<ExpNode*>$2);
                }
                //as you know registers $v0-$v1 hold the returned values of a function
                //at first we move the returned expression to reg v0
                // then it's the same explenation as abvove in the previous rule
                CodeBuffer::instance().emit("move $v0, " + regToString(($2)->reg));
                returnTempReg($2->reg);
                StatementNode* tempSt12 = new StatementNode();
                *(tempSt12->returnList) = CodeBuffer::makelist(CodeBuffer::instance().emit("j ")); //shani: caused sigfault, this is why we use tempSt12!
                //*(tempSt12->returnList)->push_back(CodeBuffer::instance().emit("j ")); //shani: t2 falls here, j without backpatch //shani1 couldnt finr "return list" in the tutorials, explain
               //CodeBuffer::instance().emit("move $sp, $fp"); //shani1 was  missing, fixed missing j in t2
                //CodeBuffer::instance().emit("jr $ra");      //shani1 was missing, fixed missing j in t2
                $$=tempSt12;
            }
         | M4 M Statement{
                //closeScope();
                SymbolTable* current_parent = current_scope_table->getParent();
                delete(current_scope_table);
                current_scope_table = current_parent;
                offsets.pop();
                if (($1)->err)
                {
                    errorMismatch(($1)->line_num);
                    exit(0);
                }
                //we want to insert M's quad as the target label for each of the instructions on the true list of M4
                //meaning M would be the target for when the expression in M4 is true
                CodeBuffer::instance().bpatch(*(dynamic_cast<ExpNode*>($1)->trueList), (dynamic_cast<MNode*>($2))->quad);
                //StatementNode* tempSt13 = new StatementNode(); //shani7 - the rule is not over!
                //$$=tempSt13; //shani7 - the rule is not over!
           }
          ElseMarker { //shani7: added M
                //we jump to else if the expression evaluates to false
                CodeBuffer::instance().bpatch(*(dynamic_cast<ExpNode*>($1)->falseList), dynamic_cast<ElseMarkerNode*>($5)->quad);
                //CodeBuffer::instance().bpatch(*(dynamic_cast<StatementNode*>($3)->breakList), dynamic_cast<ElseMarkerNode*>($5)->quad); //shani7 - was missing
              //  CodeBuffer::instance().bpatch(*(dynamic_cast<StatementNode*>($3)->breakList), dynamic_cast<MNode*>($6)->quad); //shani7 statment1 breake target is M - label of the end of if...else section
                //CodeBuffer::instance().bpatch(*(dynamic_cast<ElseMarkerNode*>($5)->breakList), dynamic_cast<MNode*>($6)->quad); //shani7 - statment2 breake target (= "ElseMarker" breake terget) is M - label of the end of if...else section
                  //generating the next jump label after the else is executed
               // CodeBuffer::instance().bpatch(*(dynamic_cast<ElseMarkerNode*>($5)->nextList), CodeBuffer::instance().genLabel()); //shani7 - no need, this is the next code in rutine, so he will automaticly comes here
                //setting the return and break lists of the if statement to be the concatenation
                //of the lists of statement inside if and the else block
                StatementNode* tempSt1 = new StatementNode();
                *(tempSt1->returnList) = CodeBuffer::merge(*(dynamic_cast<StatementNode*>($3)->returnList), *(dynamic_cast<ElseMarkerNode*>($5)->returnList));
                *(tempSt1->breakList) = CodeBuffer::merge(*(dynamic_cast<StatementNode*>($3)->breakList), *(dynamic_cast<ElseMarkerNode*>($5)->breakList));
                $$=tempSt1;
         }

        //rach1: I don't understand why you added the IW marker. what is it for? why does it help? //shani2: please see the comment 3 lines below... i'll never change somthing withpur explaining
        | WHILE IW LPAREN M Exp RPAREN //here
         {
                //turn on flag of loop
                //inside_while = true; //racheli, the Exp is brake, then is will be false in the break rule code, i move it to IW (in while)
                //check expression type
                if (($5)->type != TYPE_BOOL) //shani: was $3
                {
                    errorMismatch(yylineno);
                    exit(0);
                }
                SymbolTable* new_scope_table = new SymbolTable(current_scope_table);
                current_scope_table = new_scope_table;
                offsets.push(offsets.top());
            }
        M Statement {
                //when exp in the while loop evaluates to true, we want to jump to the label defined in the 2nd M
                CodeBuffer::instance().bpatch(*(dynamic_cast<ExpNode*>($5)->trueList), dynamic_cast<MNode*>($8)->quad); //shani: was $6
                CodeBuffer::instance().bpatch(*(dynamic_cast<StatementNode*>($9)->nextList), dynamic_cast<MNode*>($4)->quad); //shani8 - was missing. required "continue" target
                //setting 1st M's label as the target for each of the instructions in the created s_list
                //meaning we jump to the 1st M label whenever we reach the end of the while loop block in order to re-evaluate the expression for entering the loop

                //*(dynamic_cast<StatementNode*>($9)->returnList) = CodeBuffer::makelist(CodeBuffer::instance().emit("j ")); // j (label)
                CodeBuffer::instance().bpatch(CodeBuffer::makelist(CodeBuffer::instance().emit("j ")), dynamic_cast<MNode*>($4)->quad); //(label) = M quad

                //we want to create a fresh label as target for the instructions in the concatenated list created by the false list of exp and break list of statement
                CodeBuffer::instance().bpatch(CodeBuffer::merge(*(dynamic_cast<ExpNode*>($5)->falseList),*(dynamic_cast<StatementNode*>($9)->breakList)), CodeBuffer::instance().genLabel());

                StatementNode* tempSt2 = new StatementNode();
                *(tempSt2->returnList) = *(dynamic_cast<StatementNode*>($9)->returnList);
                *(tempSt2->nextList)=(CodeBuffer::merge(*(dynamic_cast<ExpNode*>($5)->falseList),*(dynamic_cast<StatementNode*>($9)->breakList))); //shani8
                //closeScope();
                SymbolTable* p = current_scope_table->getParent();
                delete(current_scope_table);
                current_scope_table = p;
                offsets.pop();
                //turn off boolean marking that we're out of the while loop
                inside_while = false;
                $$=tempSt2;
            }
        | BREAK SC{
                if (!inside_while)
                {
                    errorUnexpectedBreak(yylineno);
                    exit(0);
                }
                StatementNode* tempSt3 = new StatementNode();
                //we want to set the break list of the lhs of the rule to include "jump" instruction
                *(tempSt3->breakList) = CodeBuffer::makelist(CodeBuffer::instance().emit("j "));
                $$=tempSt3;
        }
        | CONTINUE SC{
                if (!inside_while)
                {
                    errorUnexpectedContinue(yylineno);
                    exit(0);
                }
                StatementNode* tempSt4 = new StatementNode();
                //we want to set the next list of the lhs of the rule to include "jump" instruction
                *(tempSt4->returnList) = CodeBuffer::makelist(CodeBuffer::instance().emit("j ")); //shani8: this is why we need nextlist in statment rach92fix2 no, we need return list here.
                $$=tempSt4;
        }

;
//marker M4
M4  :  IF LPAREN Exp RPAREN {
            // $$ = $3; - this runs over the exp son fields
            if (($3)->type != TYPE_BOOL)
            {
                ($$)->err = true;
                ($$)->line_num = yylineno;
            }
            SymbolTable* new_table = new SymbolTable(current_scope_table);
            current_scope_table = new_table;
            offsets.push(offsets.top());
            $$=dynamic_cast<ExpNode*>($3); //shani
};
//marker ElseMarker
ElseMarker  :  /*epsilon*/  {
            //we derive this when else is false (therefore epsilon is derived)
            //so we only need to set its next list to a new list containing the jump instruction
            //and set its quad to some fresh label
            ElseMarkerNode* tempEM = new ElseMarkerNode();
            //*(tempEM->nextList) = CodeBuffer::makelist(CodeBuffer::instance().emit("j ")); //shani7
            tempEM->quad = CodeBuffer::instance().genLabel();
            $$=tempEM;
        }
        %prec IF
        | ELSE  //shani 7 deleted N
                // when we reach here N holds the new next list (containing only the jump instruction)
                //explanation continues in the rule bellow
                //information on N, M is in their rules

                {
                SymbolTable* new_scope_table = new SymbolTable(current_scope_table);
                current_scope_table = new_scope_table;
                offsets.push(offsets.top());
                }
        M Statement{
                //M's quad holds the label we want to jump to (the "j" was emitted above when N was derived)
                //closeScope();
                SymbolTable* p = current_scope_table->getParent();
                delete(current_scope_table);
                current_scope_table = p;
                offsets.pop();
                //setting ElseMarker's fields in order to backpatch after it's derived
                //FYI: (according to the turorial) the right parentesis "{" in the beginning
                // of the else block between N and M is counted also,
                //therefore $4 refers to M, $5 refers to statement
                ElseMarkerNode* tempEM2 = new ElseMarkerNode();
                //*(tempEM2->nextList) = *(dynamic_cast<NNode*>($2)->nextList); //shani7
                tempEM2->quad = dynamic_cast<MNode*>($3)->quad; //shani7 changed to $3
                *(tempEM2->returnList) = *(dynamic_cast<StatementNode*>($4)->returnList); //shani7 changed to $4
                *(tempEM2->breakList) = *(dynamic_cast<StatementNode*>($4)->breakList); //shani7 changed to $4
                $$=tempEM2;
        }
        %prec ELSE
        ;
Call : ID LPAREN ExpList RPAREN  {
            //check that function's name isn't "main", else error

            if (($1)->name == "main")
            {
                errorMismatch(yylineno);
                exit(0);
            }
            TableEntryFunc* f = (TableEntryFunc*)current_scope_table->getEntry(($1)->name);
            if (!f)
            {
                errorUndefFunc(yylineno, ($1)->name);
                exit(0);
            }

            //compare arguament list to declaration list
            if (!(f->compareArgumentTypes((dynamic_cast<ExpListNode*>($3))->exp_list)))
            {
                //set vector of types as strings to send as parameter to error function
                std::vector<std::string> types;
                for (std::vector<FormalDeclNode*>::const_iterator it = f->declaration_list->begin();
                     it != f->declaration_list->end(); it++)
                {
                    if((*it)->type == TYPE_STRUCTID){
                        types.push_back("struct "+(*it)->s_name);
                    }
                    else
                        types.push_back(typeToString((*it)->type));
                }
                errorPrototypeMismatch(yylineno, ($1)->name, types);
                exit(0);
            }
            CallNode* temp7 = new CallNode();
            temp7->return_type = f->return_type;
            $$ = temp7;

            //preparing stack for saved registers sections $S0-$S7 //shani2: what about t registers. we does use them... in fact, "getTempReg" function retruns the first aviliable function, and it will useally return t reg.
            for (int i=0;i<NUM_OF_TEMP_REGS;i++)
            {
                //if used reg - save its value on stack
                if (!(AvailRegs[i]))
                {
                    //loads used reg on stack
                    CodeBuffer::instance().emit("subu $sp, $sp, 4");
                    CodeBuffer::instance().emit("sw " + regToString(TempReg(i)) + ", ($sp)");
                    //reset register since its value was already saved on the stack above
                    //returnTempReg(TempReg(i));
                }
            }
            //preparing stack for next section:
            CodeBuffer::instance().emit("subu $sp, $sp, 4");
            // saving old frame pointer on stack
            CodeBuffer::instance().emit("sw $fp, ($sp)");
            //preparing stack for the return address section
            CodeBuffer::instance().emit("subu $sp, $sp, 4");
            //saving return address on stack
            CodeBuffer::instance().emit("sw $ra, ($sp)");
            int num =0; //num of arguments
            //arguments section
            std::vector<ExpNode*>* expList = (dynamic_cast<ExpListNode*>($3))->exp_list;
            for (std::vector<ExpNode*>::iterator it = expList->begin(); it != expList->end(); ++it) {
                if ((*it)->type == TYPE_STRUCTID)
                {
                    TableEntry* st_node = current_scope_table->getEntry((*it)->name);
                    int s_offset = (st_node->f_offset)*4;//sn
                    int num_fields = (*it)->size;
                    int curr_offset;//sn
                    TempReg tmp = getAvailReg(); //shani4: sw is only from register, so i added this lines to move the value to a register befor sw
                    //save fields on stack
                    for (int i =0; i< num_fields; i++){
                        curr_offset = s_offset + i*4;
                        //save value of field on stack
                        CodeBuffer::instance().emit("subu $sp, $sp, 4");
                        CodeBuffer::instance().emit("lw "+regToString(tmp)+", "+ intToString(-curr_offset) +"($fp)"); //shani4: this line is needed for sw instruction //shani7: changed to -4 instead of --x($fp)
                        CodeBuffer::instance().emit("sw "+regToString(tmp)+", ($sp)"); //shani4 : $fp was fp
                        num++;
                    }
                    returnTempReg(tmp); //shani4
                }
                    //if of regular type
                else
                {
                    CodeBuffer::instance().emit("subu $sp, $sp, 4");
                    //saving argument on stack
                    CodeBuffer::instance().emit("sw " + regToString((*it)->reg) + ", ($sp)");
                    num++;
                }

            }
            //end of pre-call, now we prepare the stack for jumping to the called function
            //make fp point to where sp points
            CodeBuffer::instance().emit("move $fp, $sp");
            //subtract one word so that sp would be one place bellow the beginning of the caller frame
            //CodeBuffer::instance().emit("subu $fp, $fp, 4"); //sn- we said the head wull alwase point to the last storaged date
            //handle cases
            if (($1)->name == "main") {
                CodeBuffer::instance().emit("jal " + ($1)->name);
            } else {
                CodeBuffer::instance().emit("jal _" + ($1)->name);
            }

            //post-call

            //add size calculated above (in words) to the current stack pointer to fold stack
            CodeBuffer::instance().emit("addu $sp, $sp, " + intToString(4*num));
            //load return address from stack to ra register
            CodeBuffer::instance().emit("lw $ra, ($sp)");
            //fold stack (fold ra spot)
            CodeBuffer::instance().emit("addu $sp, $sp, 4");
            //load old (saved on stack) fp to fp
            CodeBuffer::instance().emit("lw $fp, ($sp)");
            //folding up one spot
            CodeBuffer::instance().emit("addu $sp, $sp, 4");

            //folding saved registers section
            for (int i=NUM_OF_TEMP_REGS-1;i!=-1;i--) //shani5:changed to -1
            {
                //if used reg - save its value on stack
                if (!(AvailRegs[i]))
                {
                    CodeBuffer::instance().emit("lw " + regToString(TempReg(i)) + ", ($sp)");
                    CodeBuffer::instance().emit("addu $sp, $sp, 4"); //shani2: was subu! this is why i got confused
                }
            }
            //rach92 changed to reverse + switched places with if bellow
            for (std::vector<ExpNode*>::reverse_iterator it = expList->rbegin(); it != expList->rend(); ++it){
                returnTempReg((*it)->reg);
            }
            //in case the function returns a value, its saved in $v0-$v1 and needs to be moved
            //to a new register which will be saved
            if (f->return_type != TYPE_VOID) {
                ($$)->reg = getAvailReg();
               // CodeBuffer::instance().emit("move " + regToString(($$)->reg) + ", $v0"); already done in call
            }

      }
        | ID LPAREN RPAREN {
            TableEntryFunc* f = (TableEntryFunc*)current_scope_table->getEntry(($1)->name);
            //  std::cout<<"h"<<endl;
            if (!f || (f->type != TYPE_FUNC)) {
                errorUndefFunc(yylineno, ($1)->name);
                exit(0);
            }

            //should be an empty list of args
            if (f->declaration_list->size() != 0)
            {
                //set vector of types as strings to send as parameter to error function
                std::vector<std::string> types;
                for (std::vector<FormalDeclNode*>::const_iterator it = f->declaration_list->begin();it != f->declaration_list->end(); it++)
                {
                    types.push_back(typeToString((*it)->type));
                }
                errorPrototypeMismatch(yylineno, ($1)->name, types);
                exit(0);
            }
            CallNode* tempC= new CallNode();
            tempC->return_type = f->return_type;
            $$ = tempC;

            //preparing stack for saved registers sections $S0-$S7
            for (int i=NUM_OF_TEMP_REGS-1;i!=-1;i--) //shani2: change to 0 see rule above + changed to reverse shani5: change to -1, fix test23
            {
                //if used reg - save its value on stack
                if (!(AvailRegs[i])){
                    //loads used reg on stack
                    CodeBuffer::instance().emit("subu $sp, $sp, 4");
                    CodeBuffer::instance().emit("sw " + regToString(TempReg(i)) + ", ($sp)");
                    //reset register since its value was already saved on the stack above
                   // returnTempReg(TempReg(i)); //shani3 was nit in error
                }
            }
            //preparing stack for next section:
            CodeBuffer::instance().emit("subu $sp, $sp, 4");
            // saving old frame pointer on stack
            CodeBuffer::instance().emit("sw $fp, ($sp)");
            //preparing stack for the return address section
            CodeBuffer::instance().emit("subu $sp, $sp, 4");
            //saving return address on stack
            CodeBuffer::instance().emit("sw $ra, ($sp)");
            //end of pre-call, now we prepare the stack for jumping to the called function
            //make fp point to where sp points
            CodeBuffer::instance().emit("move $fp, $sp");
            //subtract one word so that sp would be one place bellow the beginning of the caller frame
            // CodeBuffer::instance().emit("subu $fp, $fp, 4"); //sn- we said the head wull alwase point to the last storaged date
            //handle cases
            if (($1)->name == "main") {
                 CodeBuffer::instance().emit("jal " + ($1)->name);
            } else {
                 CodeBuffer::instance().emit("jal _" + ($1)->name);
            }
            //post-call
            //load return address from stack to ra register
            CodeBuffer::instance().emit("lw $ra, ($sp)");
            //fold stack (fold ra spot)
            CodeBuffer::instance().emit("addu $sp, $sp, 4");
            //load old (saved on stack) fp to fp
            CodeBuffer::instance().emit("lw $fp, ($sp)");
            //folding up one spot
            CodeBuffer::instance().emit("addu $sp, $sp, 4");
            //folding saved registers section
            for (int i=0;i<NUM_OF_TEMP_REGS;i++) //shani2: change to 0 see rule above
            {
            //if used reg - save its value on stack
                if (!(AvailRegs[i]))
                {
                    CodeBuffer::instance().emit("lw " + regToString(TempReg(i)) + ", ($sp)");
                    CodeBuffer::instance().emit("addu $sp, $sp, 4"); //shani2: was subu!
                    //returnTempReg(TempReg(i));
                }
            }

            //in case the function returns a value, its saved in $v0-$v1 and needs to be moved
            //to a new register which will be saved
            if (f->return_type != TYPE_VOID) {
                ($$)->reg = getAvailReg();
               // CodeBuffer::instance().emit("move " + regToString(($$)->reg) + ", $v0"); shani5 alredy done in call
            }
} ;

ExpList : Exp {
            //*rach*
            if (($1)->type == TYPE_BOOL)
              evaluateBoolean(dynamic_cast<ExpNode*>($1));
            // add the experssion to the expression list
            ExpListNode* temp5 = new ExpListNode();
            (temp5->exp_list)->push_back(dynamic_cast<ExpNode*>($1));
            $$ = temp5;
        }
        | Exp{
            //*rach*
            if (($1)->type == TYPE_BOOL)
                evaluateBoolean(dynamic_cast<ExpNode*>($1));
        }
        COMMA ExpList {
           ExpListNode* temp6 = new ExpListNode();
           temp6->exp_list = (dynamic_cast<ExpListNode*>($4))->exp_list; //shani was $3
           (temp6->exp_list)->push_back(dynamic_cast<ExpNode*>($1));
           $$ = temp6;
           //current list will be the list it derives with the exp is derives
} ;

Type :   INT{
            TypeNode* t_node = new TypeNode();
            t_node->type = TYPE_INT;
            t_node->value = TYPE_INT;
            $$ = t_node;
        }
        | BYTE{
            TypeNode* t_node = new TypeNode();
            t_node->type = TYPE_BYTE;
            t_node->value = TYPE_BYTE;
            $$ = t_node;
        }
        | BOOL{
            TypeNode* t_node = new TypeNode();
            t_node->type = TYPE_BOOL;
            t_node->value = TYPE_BOOL;
            $$ = t_node;
} ;

StructType : STRUCT ID ID{
        TableEntryStruct* IdVariable = (TableEntryStruct*)current_scope_table->getEntry(($2)->name);
        if(!IdVariable){
             //the struct was never defined
            errorUndefStruct(yylineno,($2)->name);
            exit(0);
        }
        StructTypeNode* temp10 = new StructTypeNode($2->name);
        temp10->type = TYPE_STRUCTID;
        temp10->name = ($3)->name;
        temp10->size = IdVariable->size;
        temp10->offset = offsets.top();
        //make place for all the future data of the struct instatce in the stuck
        int num_of_fields = IdVariable->Fields->s_list->size();
        for ( int i = 0 ; i <num_of_fields  ; i++){
            CodeBuffer::instance().emit("subu $sp, $sp, 4"); //increase stuck space by one (stuck is grouing towrards the lower address)
            CodeBuffer::instance().emit("sw $zero, ($sp)"); //init stuct space of the variable by null
        }
        $$ = temp10;
};

ML :  { /* epsilon */
        //create new scope table for the scope
        SymbolTable* new_scope = new SymbolTable(current_scope_table);
        //the current scope is the new scope now
        current_scope_table = new_scope;
        //add the top value to the offsets stuck
        offsets.push(offsets.top());
};

Exp : LPAREN Exp RPAREN{
            ExpNode* Exp = new ExpNode("");
            Exp = dynamic_cast<ExpNode*>($2);
            $$ = Exp;
        }
     | Exp MUL Exp{
            //binops is defined on int and byte only (among the types that we are using in this project)
            if ((($1)->type != TYPE_INT && ($1)->type != TYPE_BYTE) || (($3)->type != TYPE_INT && ($3)->type != TYPE_BYTE)) {
                errorMismatch(yylineno);
                exit(0);
            }
            ExpNode* tempMul = new ExpNode("");
            tempMul->size = 1; //both INT  and BYTE are size 1
            //the exp type is the type of the bigger of the $1 and $3 expressions
            if (($1)->type == TYPE_INT  || ($3)->type == TYPE_INT)
               tempMul->type = TYPE_INT;
            else
                tempMul->type = TYPE_BYTE;

            TempReg reg1 = dynamic_cast<ExpNode*>($1)->reg;
            TempReg reg3 = dynamic_cast<ExpNode*>($3)->reg;
            tempMul->reg = reg1;
            std::string reg1_s = regToString(reg1);
            std::string reg3_s = regToString(reg3);
            std::string reg_s = regToString(reg1); //reg1 = reg
            //note: no such thing as "mulu"
            CodeBuffer::instance().emit("mul " + reg_s + ", " + reg1_s + ", " + reg3_s);
            if ( $1->type == TYPE_BYTE && $3->type == TYPE_BYTE) //if it was bits multiplication
                CodeBuffer::instance().emit("and " + reg_s + ", " + reg_s + ", 255"); //take first 8 bits of the answer
            returnTempReg(reg3);
            $$=tempMul;
       }

        | Exp DIV Exp{
            //binops is defined on int and byte only (among the types that we are using in this project)
            if ((($1)->type != TYPE_INT && ($1)->type != TYPE_BYTE) || (($3)->type != TYPE_INT && ($3)->type != TYPE_BYTE)) {
                errorMismatch(yylineno);
                exit(0);
            }
            ExpNode* tempDiv = new ExpNode("");
            tempDiv->size = 1; //both INT  and BYTE are size 1
            //the exp type is the type of the bigger of the $1 and $3 expressions
            if (($1)->type == TYPE_INT  || ($3)->type == TYPE_INT)
              tempDiv->type = TYPE_INT;
            else
              tempDiv->type = TYPE_BYTE;

            TempReg reg1 = dynamic_cast<ExpNode*>($1)->reg;
            TempReg reg3 = dynamic_cast<ExpNode*>($3)->reg;
            tempDiv->reg = reg1;
            std::string reg1_s = regToString(reg1);
            std::string reg3_s = regToString(reg3);
            std::string reg_s = regToString(reg1); //reg1 = reg
            //if the second expression is zero, then goto zero handeling code
            CodeBuffer::instance().emit("beq " + reg3_s + ", 0, zero_handler"); //zero handler is the name of the lable of the div in zero handler code
            //if the devision is between bytes is unsigned
            if ( $1->type == TYPE_BYTE && $3->type == TYPE_BYTE){
                CodeBuffer::instance().emit("divu " + reg_s + ", " + reg1_s + ", " + reg3_s);
                CodeBuffer::instance().emit("and " + reg_s + ", " + reg_s + ", 255"); //take first 8 bits of the answer
            }else {
               CodeBuffer::instance().emit("div " + reg_s + ", " + reg1_s + ", " + reg3_s); //devition with int involved is signed
            }
            returnTempReg(reg3);
            $$=tempDiv;
          }
         | Exp MINUS Exp{
            //binops is defined on int and byte only (among the types that we are using in this project)
            if ((($1)->type != TYPE_INT && ($1)->type != TYPE_BYTE) || (($3)->type != TYPE_INT && ($3)->type != TYPE_BYTE)) {
                errorMismatch(yylineno);
                exit(0);
            }
            ExpNode* tempMin = new ExpNode("");
            tempMin->size = 1; //both INT  and BYTE are size 1
            //the exp type is the type of the bigger of the $1 and $3 expressions
            if (($1)->type == TYPE_INT  || ($3)->type == TYPE_INT)
              tempMin->type = TYPE_INT;
            else
             tempMin->type = TYPE_BYTE;

            TempReg reg1 = dynamic_cast<ExpNode*>($1)->reg;
            TempReg reg3 = dynamic_cast<ExpNode*>($3)->reg;
            tempMin->reg = reg1;
            std::string reg1_s = regToString(reg1);
            std::string reg3_s = regToString(reg3);
            std::string reg_s = regToString(reg1); //reg1 = reg
            //if the sub is between bytes it is unsigned
            if ( $1->type == TYPE_BYTE && $3->type == TYPE_BYTE){
                CodeBuffer::instance().emit("subu " + reg_s + ", " + reg1_s + ", " + reg3_s);
                CodeBuffer::instance().emit("and " + reg_s + ", " + reg_s + ", 255"); //take first 8 bits of the answer
            }else {
                 CodeBuffer::instance().emit("sub " + reg_s + ", " + reg1_s + ", " + reg3_s); //sub with int involved is signed
            }
            returnTempReg(reg3);
            $$=tempMin;
            }
        | Exp PLUS Exp{
            //binops is defined on int and byte only (among the types that we are using in this project)
            if ((($1)->type != TYPE_INT && ($1)->type != TYPE_BYTE) || (($3)->type != TYPE_INT && ($3)->type != TYPE_BYTE)) {
                errorMismatch(yylineno);
                exit(0);
            }
            ExpNode* tempPlu = new ExpNode("");
            tempPlu->size = 1; //both INT  and BYTE are size 1
            //the exp type is the type of the bigger of the $1 and $3 expressions
            if (($1)->type == TYPE_INT  || ($3)->type == TYPE_INT)
              tempPlu->type = TYPE_INT;
            else
                tempPlu->type = TYPE_BYTE;

            TempReg reg1 = dynamic_cast<ExpNode*>($1)->reg;
            TempReg reg3 = dynamic_cast<ExpNode*>($3)->reg;
            tempPlu->reg = reg1;
            std::string reg1_s = regToString(reg1);
            std::string reg3_s = regToString(reg3);
            std::string reg_s = regToString(reg1); //reg1 = reg
            //if the add is between bytes it is unsigned
            if ( $1->type == TYPE_BYTE && $3->type == TYPE_BYTE){
                CodeBuffer::instance().emit("addu " + reg_s + ", " + reg1_s + ", " + reg3_s);
                CodeBuffer::instance().emit("and " + reg_s + ", " + reg_s + ", 255"); //take first 8 bits of the answer
            }else {
                CodeBuffer::instance().emit("add " + reg_s + ", " + reg1_s + ", " + reg3_s); //add with int involved is signed
            }
            returnTempReg(reg3);
            $$=tempPlu;
         }

        | ID {
            //we need to check if this variable is defined in the upper or current scopes
            //if this variable is defined, we want to use it, therefore $1.type is not right, because we want the type of the variable, not the type of the token
            TableEntry* IdVariable = current_scope_table->getEntry(($1)->name);
            if(!IdVariable){
                //the variable was never defined
                errorUndef(yylineno,($1)->name);
                exit(0);
            }

            // the exp type and size is the variable type and size
            ExpNode* tempID = new ExpNode($1->name);
            if (IdVariable->type == TYPE_STRUCTID){
                TableEntryStructType* sType = new TableEntryStructType();
                sType  = dynamic_cast<TableEntryStructType*>(current_scope_table->getEntry(($1)->name));
                if (!sType || sType->type != TYPE_STRUCTID)
                { //no such structid
                    errorUndef(yylineno, ($1)->name);
                    exit(0);
                }

                TableEntryStruct* s = new TableEntryStruct();
                s  = dynamic_cast<TableEntryStruct*>(current_scope_table->getEntry(sType->structName));
                if (!s || s->type != TYPE_STRUCT)
                { //no such struct
                    errorUndef(yylineno, sType->structName);
                    exit(0);
                }

                tempID->s_name = sType->structName;
            }
            tempID->type = IdVariable->type;
            tempID->size = IdVariable->size;
            tempID->name = IdVariable->name;
            tempID->reg = getAvailReg();
            int offset = (IdVariable->f_offset)*4;//rach92 now offset holds (-1+1)*4=0 changed so that when we get an argument of a function from the stack, it will be loaded from the correct place //shani3- changed it back cause found the problem
            if (IdVariable->type == TYPE_STRUCTID){
                //load the *address* of the start of the struct in the stuct to the temp reg
                CodeBuffer::instance().emit("subu " + regToString(tempID->reg) + ", $fp, " + intToString(offset)); //stuck is growing towrards the lower address
            }

            //if the id value is bool handle it now. it is forbidden to store boolean variables in tmp regs
            else if (tempID->type == TYPE_BOOL){
                //save this line: "beq id_value , 1 , (label)" in order to later perform backpatch to the lable
                std::vector<int> line_with_quad = CodeBuffer::makelist(CodeBuffer::instance().emit("beq " + regToString(tempID->reg) + ", 1, "));
                CodeBuffer::instance().genLabel();                              //false:
                (tempID)->falseList->push_back(CodeBuffer::instance().emit("j ")); //goto ___
                std:: string trueLabel = CodeBuffer::instance().genLabel();     //true:
                (tempID)->trueList->push_back(CodeBuffer::instance().emit("j "));  //goto ___
                CodeBuffer::instance().bpatch(line_with_quad, trueLabel); //(label) = trueLabel
                returnTempReg(tempID->reg); //we already used the return value , no need for this temp reg no more //todo: this is unreachable by assembly
                (tempID)->reg = NONE;
            }
            //shani3: the else if was if. if was runnig also in the case the type was bool - this was the main problem pf t2
            else{
                offset = -offset; //stuck is growing towrards the lower address
                //buffer: "lw id_reg, -offset($fp)"
                CodeBuffer::instance().emit("lw " + regToString(tempID->reg) + " , " + intToString(offset) + "($fp)");
            }
            $$ = tempID;
          }

        | ID PERIOD ID{
            //check if $1 is struct name and $3 is its field
            TableEntryStructType* sType = new TableEntryStructType();
            sType  = dynamic_cast<TableEntryStructType*>(current_scope_table->getEntry(($1)->name));
            if (!sType || sType->type != TYPE_STRUCTID)
            { //no such structid
                errorUndef(yylineno, ($1)->name);
                exit(0);
            }

            TableEntryStruct* s = new TableEntryStruct();
            s  = dynamic_cast<TableEntryStruct*>(current_scope_table->getEntry(sType->structName));
            if (!s || s->type != TYPE_STRUCT)
            { //no such struct
                errorUndef(yylineno, sType->structName);
                exit(0);
            }

            StructMemNode* field = new StructMemNode();
            field= s->getField(($3)->name);

            if (!field)
            {
                errorUndefStructMember(yylineno, ($1)->name);
                exit(0);
            }
            ExpNode* tempIDID = new ExpNode("");
            tempIDID->type = field->type;
            tempIDID->size = ($1)->size;
          //  int struct_offset = -((sType->f_offset)*4); //struct_offset($fp) is the place of the start of the struct fields in the stuck //sn
            int field_offset = ((sType->f_offset) + (field->relative_offset))*4;
            tempIDID->reg = getAvailReg();//shani4 - was missing
            //buffer: "lw id_reg, field_offset($fp)" - load the field value to the ID temp buffer
            CodeBuffer::instance().emit("lw " + regToString(tempIDID->reg) + " , " + intToString(-field_offset) + "($fp)");

            //if the field value is bool handle it now. it is forbidden to store boolean variables in tmp regs
            if ((dynamic_cast<IdNode*>($3))->type == TYPE_BOOL){
                //save this line: "beq id_value , 1 , (label)" in order to later perform backpatch to the lable
                std::vector<int> line_with_quad = CodeBuffer::makelist(CodeBuffer::instance().emit("beq " + regToString(tempIDID->reg) + ", 1, "));
                CodeBuffer::instance().genLabel();                              //false:
                (tempIDID)->falseList->push_back(CodeBuffer::instance().emit("j ")); //goto ___
                std:: string trueLabel = CodeBuffer::instance().genLabel();     //true:
                (tempIDID)->trueList->push_back(CodeBuffer::instance().emit("j "));  //goto ___
                CodeBuffer::instance().bpatch(line_with_quad, trueLabel); //(label) = trueLabel
                returnTempReg(tempIDID->reg); //we already used the return value , no need for this temp reg no more //shani1: todo: this is unreachable by assembly
                (tempIDID)->reg = NONE;
            }
            $$ = tempIDID;
          }
        | Call {
            //if the exp derives a function call, it's value will be the return type
            ExpNode* tempCall = new ExpNode("");
            tempCall->type = (dynamic_cast<CallNode*>($1))->return_type;
            tempCall->reg = getAvailReg();
            //the return value is stored in $v0 as requested
            CodeBuffer::instance().emit("move " + regToString(tempCall->reg) + ", $v0");
            //if the return value is bool habdle it now. it is forbidden to store boolean variables in tmp regs
            if ((dynamic_cast<CallNode*>($1))->return_type == TYPE_BOOL){
                // exp = f() (func_ans) - bool
                //save this line: "beq func_ans , 1 , (label)" in order to later perform backpatch to the lable
                std::vector<int> line_with_quad = CodeBuffer::makelist(CodeBuffer::instance().emit("beq " + regToString(tempCall->reg) + ", 1, "));
                CodeBuffer::instance().genLabel();                              //false:
                (tempCall)->falseList->push_back(CodeBuffer::instance().emit("j ")); //goto ___
                std::string trueLabel = CodeBuffer::instance().genLabel();     //true:
                (tempCall)->trueList->push_back(CodeBuffer::instance().emit("j "));  //goto ___
                CodeBuffer::instance().bpatch(line_with_quad, trueLabel); //(label) = trueLabel
                returnTempReg(tempCall->reg); //we already used the return value , no need for this temp reg no more //shani1: todo: this is unreachable by assembly
                (tempCall)->reg = NONE;
            }
            $$ = tempCall;
        }
        | NUM {
            ExpNode* tempE1 = new ExpNode(($1)->name);
            //exp type = num type = int
            tempE1->type = TYPE_INT;
            tempE1->size = 1; //Int size is 1
            tempE1->value = ($1)->name;
            tempE1->reg = getAvailReg(); //put the num in temp reg for future calculations
            //load num value to register (li = load immidiate)
            CodeBuffer::instance().emit("li "+regToString(tempE1->reg)+", "+tempE1->value);
            $$ = tempE1;
        }
        | NUM B {
                const char * c = ((($1))->name).c_str();
                if (std::strtol(c, NULL, 0) > 255)
                {
                    errorByteTooLarge(yylineno, (($1))->name);
                    exit(0);
                }
                //exp type = num type = byte
                ExpNode* tempE2 = new ExpNode(($1)->name);
                tempE2->type = TYPE_BYTE;
                tempE2->size = 1; //byte size is 1
                tempE2->value = ($1)->name;
                //put the num in temp reg for future calaulations
                tempE2->reg = getAvailReg();
                //load num value to register (li = load immidiate)
                CodeBuffer::instance().emit("li "+regToString(tempE2->reg)+", "+tempE2->value);
                $$ = tempE2;
        }
        | STRING{
            ExpNode* tempE3 = new ExpNode(($1)->name);
            //exp type = num type = string
            tempE3->type = TYPE_STRING;
            tempE3->size = 1; //string size is 1
            tempE3->value = ($1)->name;
            tempE3->reg = getAvailReg();
            //load string ascii value to register from the data buffer (la = load address)
            CodeBuffer::instance().emit("la " + regToString(tempE3->reg) + ", " + CodeBuffer::instance().genDataLabel());
            //load string value to data buffer to store it's ascii string value
            CodeBuffer::instance().emitData("	.asciiz " + tempE3->value);
            ($$)=tempE3;
        }
        | TRUE{
            //exp type = true type = bool
            ExpNode* tempE4 = new ExpNode(($1)->name);
            tempE4->type = TYPE_BOOL;
            tempE4->size = 1; //bool size is 1
            tempE4->value = ($1)->name;
            tempE4->name = "true";
            tempE4->reg = NONE;
            //*rach*
            *(tempE4->trueList) = CodeBuffer::makelist(CodeBuffer::instance().emit("j ")); //shani: was"j" - missing space
            /*when we will no what supposed to happend (which code part should be running) when this exp is true,
             we will backpatch the address of the code to the empty space in the goto__ */
            //tempE4->trueList->push_back(CodeBuffer::instance().emit("j "));
            //no false list, the exp is true therefor the code when he will jump to when the exp is false is irrelevent
            ($$)=tempE4;
        }
        | FALSE{
            ExpNode* tempE5 = new ExpNode(($1)->name);
            //exp type = false type = bool
            tempE5->type = TYPE_BOOL;
            tempE5->size = 1; //bool size is 1
            tempE5->value = ($1)->name;
            tempE5->name = "false";
            tempE5->reg = NONE;
            //*rach*
            //rach92 was trueList
            *(tempE5->falseList) = CodeBuffer::makelist(CodeBuffer::instance().emit("j ")); //shani: was"j" - missing space
            /*when we will no what supposed to happend (which code part should be running) when this exp is false,
             we will backpatch the address of the code to the empty space in the goto__ */
            //tempE5->falseList->push_back(CodeBuffer::instance().emit("j ")); //goto ___
            //no true list, the exp is false therefor the code when he will jump to when the wxp is true is irrelevent
            ($$)=tempE5;
        }
        | NOT Exp {
                if(($2)->type != TYPE_BOOL){
                    //not operator is valid only on bool variables
                    errorMismatch(yylineno);
                    exit(0);
                }
                ExpNode* tempEx5 = new ExpNode("");
                tempEx5->type = TYPE_BOOL;
                tempEx5->size = 1; //bool size is 1
                tempEx5->reg = ($2)->reg;   //rach92fix
                //exp = not exp1 --> exp false list is exp1 true list. exp false list is exp1 true list.
                //std::vector<int> tmpList = *((tempEx5)->trueList);        //rach92fix what is this for?
                *((tempEx5)->trueList) = *((dynamic_cast<ExpNode*>$2)->falseList);
                *((tempEx5)->falseList) = *((dynamic_cast<ExpNode*>$2)->trueList);  //rach92fix
                $$=tempEx5;
        }
        | Exp AND M Exp{
                if(($1)->type != TYPE_BOOL || ($4)->type != TYPE_BOOL){
                    //and operator is valid only on bool variables
                    errorMismatch(yylineno);
                    exit(0);
                }
                ExpNode* tempEx4 = new ExpNode("");
                tempEx4->type = TYPE_BOOL;
                tempEx4->size = 1; //bool size is 1
                //exp = exp1 and (lable) exp2
                //if exp1 is true, goto label
                tempEx4->reg = ($1)->reg; //rach92fix
                CodeBuffer::instance().bpatch(*((dynamic_cast<ExpNode*>$1)->trueList), (dynamic_cast<MNode*>$3)->quad);
                //if exp2 if true then go to the true lable of exp2
                *((tempEx4)->trueList) = *((dynamic_cast<ExpNode*>$4)->trueList);
                //if exp1 if false goto the exp false lable. if exp2 if false goto the exp false lable.
                *((tempEx4)->falseList) = CodeBuffer::merge(*((dynamic_cast<ExpNode*>$1)->falseList),*((dynamic_cast<ExpNode*>$4)->falseList));
                $$ = tempEx4;
        }
        | Exp OR M Exp{
            if (($1)->type != TYPE_BOOL || ($4)->type != TYPE_BOOL){
                //or operator is valid only on bool variables
                errorMismatch(yylineno);
                exit(0);
            }
            ExpNode* tempEx3 = new ExpNode("");
            tempEx3->type = TYPE_BOOL;
            tempEx3->size = 1; //bool size is 1
            //exp = exp1 or (lable) exp2
            tempEx3->reg = ($1)->reg;   //rach92fix
            //if exp1 if false goto lable
            CodeBuffer::instance().bpatch(*((dynamic_cast<ExpNode*>$1)->falseList), (dynamic_cast<MNode*>$3)->quad);
            //if exp1 if true goto the exp true label, if exp2 is true goto the exp true lable.
            *((tempEx3)->trueList) = CodeBuffer::merge(*((dynamic_cast<ExpNode*>$1)->trueList),*((dynamic_cast<ExpNode*>$4)->trueList));
            //if exp2 is false then goto the exp false lable
            *((tempEx3)->falseList) = *((dynamic_cast<ExpNode*>$4)->falseList);

            $$ = tempEx3;
        }
        | Exp EQUAL Exp{
            if ((($1)->type != TYPE_INT && ($1)->type != TYPE_BYTE) || (($3)->type != TYPE_BYTE && ($3)->type != TYPE_INT)){
                errorMismatch(yylineno);
                exit(0);
            }
            ExpNode* tempEx2 = new ExpNode("");
            tempEx2->type = TYPE_BOOL; // return type of relop operator is bool
            tempEx2->size = 1; //bool size is 1
            tempEx2->reg = NONE; //no temp reg yet
            // exp = exp1 == exp2
            //in buffer: beq exp1, exp2, ___ (true lable)
            //            ___(false lable)
            (tempEx2)->trueList->push_back(CodeBuffer::instance().emit("beq "+regToString((dynamic_cast<ExpNode*>$1)->reg)+", "+regToString((dynamic_cast<ExpNode*>$3)->reg)+", "));
            returnTempReg((dynamic_cast<ExpNode*>$1)->reg);
            returnTempReg((dynamic_cast<ExpNode*>$3)->reg);
            (tempEx2)->falseList->push_back(CodeBuffer::instance().emit("j ")); //if exp1 != exp2 goto___ (false lable) //shani1 - place changed, we want to return registers before we hump to another place in the code
            $$=tempEx2;
        }
        | Exp NOTEQUAL Exp{
            if ((($1)->type != TYPE_INT && ($1)->type != TYPE_BYTE) || (($3)->type != TYPE_BYTE && ($3)->type != TYPE_INT)){
                errorMismatch(yylineno);
                exit(0);
            }
            ExpNode* tempEx2 = new ExpNode("");
            tempEx2->type = TYPE_BOOL; // return type of relop operator is bool
            tempEx2->size = 1; //bool size is 1
            tempEx2->reg = NONE; //no temp reg yet
            // exp = exp1 != exp2
            //in buffer: bne exp1, exp2, ___ (true lable)
            //            ___(false lable)
            (tempEx2)->trueList->push_back(CodeBuffer::instance().emit("bne "+regToString((dynamic_cast<ExpNode*>$1)->reg)+", "+regToString((dynamic_cast<ExpNode*>$3)->reg)+", "));
            returnTempReg((dynamic_cast<ExpNode*>$1)->reg);
            returnTempReg((dynamic_cast<ExpNode*>$3)->reg);
            (tempEx2)->falseList->push_back(CodeBuffer::instance().emit("j ")); //if exp1 == exp2 goto___ (false lable)//shani1 - place changed, we want to return registers before we hump to another place in the code
            $$=tempEx2;
        }
        | Exp BIGGER Exp{
            if ((($1)->type != TYPE_INT && ($1)->type != TYPE_BYTE) || (($3)->type != TYPE_BYTE && ($3)->type != TYPE_INT)){
                //and operator is valid only on numerical variables
                errorMismatch(yylineno);
                exit(0);
            }

            ExpNode* tempEx1 = new ExpNode("");
            tempEx1->type = TYPE_BOOL; // return type of relop operator is bool
            tempEx1->size = 1; //bool size is 1
            tempEx1->reg = NONE; //no temp reg yet
            // exp = exp1 > exp2
            //in buffer: bgt exp1, exp2, ___ (true lable)
            //            ___(false lable)
            if (($1)->type == TYPE_BYTE && ($3)->type == TYPE_BYTE) // compare between bytes //one of them was !=
                (tempEx1)->trueList->push_back(CodeBuffer::instance().emit("bgtu "+regToString((dynamic_cast<ExpNode*>$1)->reg)+", "+regToString((dynamic_cast<ExpNode*>$3)->reg)+", "));
            else //regular comapare
                 (tempEx1)->trueList->push_back(CodeBuffer::instance().emit("bgt "+regToString((dynamic_cast<ExpNode*>$1)->reg)+", "+regToString((dynamic_cast<ExpNode*>$3)->reg)+", "));
            returnTempReg((dynamic_cast<ExpNode*>$1)->reg);
            returnTempReg((dynamic_cast<ExpNode*>$3)->reg);
            (tempEx1)->falseList->push_back(CodeBuffer::instance().emit("j ")); //if exp1 <=exp2 goto___ (false lable)  //shani1 - place changed, we want to return registers before we hump to another place in the code
            $$ = tempEx1;
        }
        | Exp SMALLER Exp{
            if ((($1)->type != TYPE_INT && ($1)->type != TYPE_BYTE) || (($3)->type != TYPE_BYTE && ($3)->type != TYPE_INT)){
                //and operator is valid only on numerical variables
                errorMismatch(yylineno);
                exit(0);
             }

            ExpNode* tempEx1 = new ExpNode("");
            tempEx1->type = TYPE_BOOL; // return type of relop operator is bool
            tempEx1->size = 1; //bool size is 1
            tempEx1->reg = NONE; //no temp reg yet
            // exp = exp1 < exp2
            //in buffer: blt exp1, exp2, ___ (true lable)
            //                    ___(false lable)
            if (($1)->type == TYPE_BYTE && ($3)->type == TYPE_BYTE) // compare between bytes shani2 : one of them was !=
                 (tempEx1)->trueList->push_back(CodeBuffer::instance().emit("bltu "+regToString((dynamic_cast<ExpNode*>$1)->reg)+", "+regToString((dynamic_cast<ExpNode*>$3)->reg)+", "));
            else //regular comapare
                (tempEx1)->trueList->push_back(CodeBuffer::instance().emit("blt "+regToString((dynamic_cast<ExpNode*>$1)->reg)+", "+regToString((dynamic_cast<ExpNode*>$3)->reg)+", "));
            returnTempReg((dynamic_cast<ExpNode*>$1)->reg);
            returnTempReg((dynamic_cast<ExpNode*>$3)->reg);
            (tempEx1)->falseList->push_back(CodeBuffer::instance().emit("j ")); //if exp1 => exp2 goto___ (false lable) //shani1 - we want to change registers before we jump to another place in the code
             $$ = tempEx1;
        }
        | Exp SEQ Exp{
            if ((($1)->type != TYPE_INT && ($1)->type != TYPE_BYTE) || (($3)->type != TYPE_BYTE && ($3)->type != TYPE_INT)){
                //and operator is valid only on numerical variables
                errorMismatch(yylineno);
                exit(0);
             }

            ExpNode* tempEx1 = new ExpNode("");
            tempEx1->type = TYPE_BOOL; // return type of relop operator is bool
            tempEx1->size = 1; //bool size is 1
            tempEx1->reg = NONE; //no temp reg yet
            // exp = exp1 <= exp2
            //in buffer: ble exp1, exp2, ___ (true lable)
            //            ___(false lable)
            if (($1)->type == TYPE_BYTE && ($3)->type == TYPE_BYTE) // compare between bytes //shani2 one of them was !=
              (tempEx1)->trueList->push_back(CodeBuffer::instance().emit("bleu "+regToString((dynamic_cast<ExpNode*>$1)->reg)+", "+regToString((dynamic_cast<ExpNode*>$3)->reg)+", "));
            else //regular comapare
              (tempEx1)->trueList->push_back(CodeBuffer::instance().emit("ble "+regToString((dynamic_cast<ExpNode*>$1)->reg)+", "+regToString((dynamic_cast<ExpNode*>$3)->reg)+", "));
            returnTempReg((dynamic_cast<ExpNode*>$1)->reg);
            returnTempReg((dynamic_cast<ExpNode*>$3)->reg);
            (tempEx1)->falseList->push_back(CodeBuffer::instance().emit("j ")); //if exp1 > exp2 goto___ (false lable) //shani1 - place changed, we want to return registers before we hump to another place in the code
            $$ = tempEx1;
        }
        | Exp BEQ Exp{
            if ((($1)->type != TYPE_INT && ($1)->type != TYPE_BYTE) || (($3)->type != TYPE_BYTE && ($3)->type != TYPE_INT)){
                //and operator is valid only on numerical variables
                errorMismatch(yylineno);
                 exit(0);
            }

            ExpNode* tempEx1 = new ExpNode("");
            tempEx1->type = TYPE_BOOL; // return type of relop operator is bool
            tempEx1->size = 1; //bool size is 1
            tempEx1->reg = NONE; //no temp reg yet
            // exp = exp1 => exp2
            //in buffer: bge exp1, exp2, ___ (true lable)
            //            ___(false lable)
            if (($1)->type == TYPE_BYTE && ($3)->type == TYPE_BYTE) // compare between bytes //one of them was !=
                 (tempEx1)->trueList->push_back(CodeBuffer::instance().emit("bgeu "+regToString((dynamic_cast<ExpNode*>$1)->reg)+", "+regToString((dynamic_cast<ExpNode*>$3)->reg)+", "));
            else //regular comapare
                (tempEx1)->trueList->push_back(CodeBuffer::instance().emit("bge "+regToString((dynamic_cast<ExpNode*>$1)->reg)+", "+regToString((dynamic_cast<ExpNode*>$3)->reg)+", "));
            returnTempReg((dynamic_cast<ExpNode*>$1)->reg);
            returnTempReg((dynamic_cast<ExpNode*>$3)->reg);
            (tempEx1)->falseList->push_back(CodeBuffer::instance().emit("j ")); //if exp1 < exp2 goto___ (false lable) //shani1 - place changed, we want to return registers before we hump to another place in the code
            $$ = tempEx1;
}
;

// m n IW markers
M : /*epsilon*/
{ //this marker evaluates labels
    MNode* new_m = new MNode(CodeBuffer::instance().genLabel());
    $$ = new_m;
}
/* shani7 - we have no use in this right now. wont compile with "useless rule"
N : /*epsilon
{
    NNode* new_n = new NNode(CodeBuffer::makelist(CodeBuffer::instance().emit("j ")));
    $$ = new_n;
}
*/
//shani1
IW : /*epsilon*/
{
    inside_while =true;
};

%%

/*USER ROUTINES*/


void yyerror(std::string m)
{
    errorSyn(yylineno);
    exit(0);
}

int main() {
   // yydebug = 1; //todo: for debug
    SymbolTable* temp_table = new SymbolTable(NULL);
    current_scope_table = temp_table;
    offsets.push(0);
    frame_offsets.push(0);
    FormalDeclNode* n = new FormalDeclNode();
    n->name = "";
    n->type = TYPE_STRING;
    n->size = 1;
    current_scope_table->insertFunctionEntry("print", TYPE_VOID,0);
    TableEntryFunc* f_print = (TableEntryFunc*)current_scope_table->getEntry("print");
    f_print->declaration_list->push_back(n);
    //print:
    CodeBuffer::instance().emit("_print:"); //shani: was print, but jal _print
    CodeBuffer::instance().emit("lw $a0,0($sp)"); //load the string to print to the printer register
    CodeBuffer::instance().emit("li $v0,4"); //service 4 is string printer service
    CodeBuffer::instance().emit("syscall"); //call service 4
    CodeBuffer::instance().emit("jr $ra"); //jump to return adress
    FormalDeclNode* n2 = new FormalDeclNode();
    n2->name = "";
    n2->type = TYPE_INT;
    n2->size = 1;
    current_scope_table->insertFunctionEntry("printi", TYPE_VOID,0);
    TableEntryFunc* f_printi = (TableEntryFunc*)current_scope_table->getEntry("printi");
    f_printi->declaration_list->push_back(n2);
    //printi:
    CodeBuffer::instance().emit("_printi:"); //shani: was printi, but jal _printi
    CodeBuffer::instance().emit("lw $a0,0($sp)"); //load the int to print to the printer register
    CodeBuffer::instance().emit("li $v0,1"); //service 1 is the int printer service
    CodeBuffer::instance().emit("syscall"); // call the int printer service
    CodeBuffer::instance().emit("jr $ra"); //jump to return adress
    current_scope_table->insertFunctionEntry("zeroHandler", TYPE_VOID,0);
    //save the string that will be printed in the case of an zero devision error in the data buffer
    CodeBuffer::instance().emitData("zeroErrorString:	.asciiz \"Error division by zero\\n\"");
    //code that will be running in case of devision in zero:
    CodeBuffer::instance().emit("zero_handler:");
    CodeBuffer::instance().emit("la $a0, zeroErrorString"); //$a0 holds syscall arguments //shani: was with ":" at the end
    CodeBuffer::instance().emit("li $v0, 4"); //service 4 is string print
    CodeBuffer::instance().emit("syscall"); //call syscall number 4
    CodeBuffer::instance().emit("j exit"); //end running after zero devision
    // yyparse(); //shani1- wasn't in comment
    //*rach* //shani1: where is the change? all i see is yyparse twice

    yyparse();
    int main_counter = 0;
    for (std::vector<TableEntry*>::const_iterator it = current_scope_table->scope_table->begin(); it != current_scope_table->scope_table->end(); it++)
    {
        if (((TableEntryFunc*)(*it))->type ==TYPE_FUNC)
        {
            if ((*it)->name == "main" && ((TableEntryFunc*)(*it))->return_type == TYPE_VOID && ((TableEntryFunc*)(*it))->declaration_list->size() == 0)
            {
                main_counter++;
            }
        }

    }
    if (main_counter != 1)
    {
        errorMainMissing();
        exit(0);
    }

    //closeScope(); //shani was not in comment
    delete(temp_table);
    CodeBuffer::instance().printDataBuffer();
    CodeBuffer::instance().printCodeBuffer();

}

//=======================================================CPP HELP FUNCTIONS=====================================================================
void printStructTypeHelp(const string& name, std::vector<StructMemNode*>* fields){
    std::vector<typeName>* Types = new std::vector<typeName>();
    std::vector<string>* Names = new std::vector<string>();
    for(std::vector<StructMemNode*>::reverse_iterator it = fields->rbegin();it!=fields->rend();it++){
        Types->push_back((*it)->type);
        Names->push_back((*it)->name);
    }
    printStructType(name, *(TypeVecToString(*Types)), *Names);
}

std::string typeToString(typeName type){
    switch (type){
        case(TYPE_BYTE) :
            return "BYTE";
        case(TYPE_BOOL) :
            return "BOOL";
        case(TYPE_INT) :
            return "INT";
        case(TYPE_STRING) :
            return "STRING";
        case(TYPE_STRUCT) :
            return "STRUCT";
        case(TYPE_STRUCTID) :
            return "STRUCTID";
        case(TYPE_VOID) :
            return "VOID";
    }
}

std::vector<string>* TypeVecToString(std::vector<typeName>& t_vec){
    std::vector<string>* s_vec = new std::vector<string>();

    for(int i=0; i< t_vec.size(); i++){
        s_vec->push_back(typeToString(t_vec[i]));
    }

    return s_vec;
}

std::vector<typeName>* declToTypes(std::vector<FormalDeclNode*>* decls){
    std::vector<typeName>* res = new std::vector<typeName>();
    for(std::vector<FormalDeclNode*>::const_iterator it = decls->begin(); it != decls->end(); it++){
        if (typeToString((*it)->type) == "STRUCTID")
            res->push_back((*it)->type);
    }
    return res;
}

std::vector<std::string>* declToStrings(std::vector<FormalDeclNode*>* decl)
{
    std::vector<std::string>* res = new std::vector<std::string>();
    for(std::vector<FormalDeclNode*>::const_iterator it = decl->begin(); it != decl->end(); ++it)
    {
        typeName type_temp = (*it)->type;
        if (typeToString(type_temp) != "STRUCTID")
            res->push_back(typeToString(type_temp));
        else
            res->push_back("struct "+(*it)->s_name);
    }
    return res;
}

//*rach* //shani1 - please explain how to use it. what if we want to get to avariable in the stuck?
void closeScope(){
    //this will contain the size of the variables in the current scope
    int size_of_vars = 0;
    for (std::vector<TableEntry *>::const_iterator it = current_scope_table->scope_table->begin();
         it != current_scope_table->scope_table->end(); ++it)
    {
        //if current iterator points to a variable
        if ((*it)->type != TYPE_FUNC && (*it)->type != TYPE_STRUCTID && (*it)->type != TYPE_STRUCT)
        {
            if ((*it)->offset >= 0)
                size_of_vars += 4*(*it)->size;
        }
    }
    CodeBuffer::instance().emit("addu $sp, $sp, " + intToString(size_of_vars));

}

// this function both finds the first avail register and marks it as used
TempReg getAvailReg(){
    for(int i=0; i< NUM_OF_TEMP_REGS; i++){
        if (AvailRegs[i]){
            AvailRegs[i] = false;
            return (TempReg)i;
        }
    }
    //this function is for debug only. please copy it and paste at the code parts where you are susspecting out of regs problem if needed.
    //do not forget to earase it from here and from all the uses in the code before submitting
    //todo: debug

    cout<<"no temp regs aviliable in *code part goes here*"<<endl;
    exit(0);

    return NONE;
}

// this function marks a register as unused
void returnTempReg(TempReg ret){
    AvailRegs[ret]=true;
    if ((int)ret<NUM_OF_TEMP_REGS) //shani8
        CodeBuffer::instance().emit("li "+regToString(ret)+", 0");
}

std::string intToString(int num){
    std::ostringstream s;
    s << num;
    return s.str();
}

std::string regToString(TempReg r_num){
    if ((int)r_num < 10){
        //reg is t type
        return "$t"+intToString((int)r_num);
    }
    else {
        //res is s type
        return "$s"+intToString((int)(r_num)-10);
    }
}

//frees up space on stack
void freeUpSpaceStack(int size) {
    CodeBuffer::instance().emit("subu $sp, $sp, " + intToString(4*size));
    //size will alwase be 1
    CodeBuffer::instance().emit("sw $zero, ($sp)"); //shani1: was 0, cannot use immidiate values in sw
}

//stores a variable saved in reg on the stack
void storeVariable(TempReg reg, int offset, int size) {
    CodeBuffer::instance().emit("sw " + regToString(reg) + ", " +intToString(-4*(offset)) + "($fp)"); //shani7: changed to -4 instead of --x($fp)
}


void evaluateBoolean(ExpNode* exp) {
    if (exp->reg == NONE)
        exp->reg = getAvailReg();
    CodeBuffer::instance().bpatch(*(exp->trueList),CodeBuffer::instance().genLabel()); //true:
    CodeBuffer::instance().emit("li " + regToString(exp->reg) + ", 1");              // li reg, 1;
    int temp = CodeBuffer::instance().emit("j ");                                   // goto____ (label)
    CodeBuffer::instance().bpatch(*(exp->falseList),CodeBuffer::instance().genLabel()); // false:
    CodeBuffer::instance().emit("li " + regToString(exp->reg) + ", 0");              // li reg, 0;
    CodeBuffer::instance().bpatch(CodeBuffer::makelist(temp),CodeBuffer::instance().genLabel()); //(label)
}
