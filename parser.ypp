%{
/*USER DECLERATIONS*/
#include <iostream>
#include "symtable.h"
#include "output.hpp"
#include <stack>
#include <cstdlib> //for exit
using namespace output; //errors defined inside the neamespace

extern int yylex();
void yyerror(std::string);
extern int yylineno;

//this will be initiated to the global scope. will be pointer to the current scope in current point in time.
SymbolTable* current_scope_table;

//the offsets stack. the ith entry in the stack contains the offset from the beginning of the ith scope
//to the variable to be inserted next
std::stack<int> offsets;

//RACHELI addition
//a boolean for knowing if we're inside a while loop
bool inside_while = false;
//a boolean for knowing weather main is defined
bool main_def = false;

//implemented at the end of the file
void printStructTypeHelp(const string& name, vector<StructMemNode>* fields);
std::vector<string>& TypeVecToString(std::vector<typeName>& t_vec);
std::string typeToString(typeName type);
void closeScope(); //todo: shani
std::vector<typeName>& declToTypes(std::vector<FormalDeclNode> decls); //todo: shani

%}
/*DECLERATIONS*/
%token VOID INT BYTE B BOOL STRUCT TRUE FALSE RETURN WHILE BREAK CONTINUE SC COMMA PERIOD ID NUM STRING
%left AND OR LPAREN RPAREN LBRACE RBRACE ARELOP
%left LBINOP
%left SBINOP
%right NOT ASSIGN
%nonassoc NARELOP
%nonassoc IF
%nonassoc ELSE

%%
/*RULES*/

//no semantics needed
Program :  Structs Funcs
;

//no semantics needed
Funcs :   FuncDecl Funcs
          | /*epsilon*/
;

// todo: SHANI
FuncDecl :  M1 LBRACE Statements RBRACE{

                ($$)->type = TYPE_FUNC;
               (dynamic_cast<FuncDeclNode*>($$))->return_type = (dynamic_cast<RetTypeNode*>($1))->type; //passed from marker //todo: Shani
                endScope();
                //this function does all the things we were askd to do in page 6 when closing a scope. see function ducomentation for more details
                closeScope();
                //return the current scope to be the outer scope
                SymbolTable* parent = current_scope_table->getParent();
                delete(current_scope_table);
                 current_scope_table = parent;
                //back to the outer scope pffset
                 offsets.pop();
           }
;

/* marker 1 */
M1 : RetType ID LPAREN Formals RPAREN {
        //to pass return typeto funcDecl   //todo: Shani
        $$->type = $1->type; //todo: Shani
         //try to insert to the current symbol table
        if (!(current_scope_table->insertFunctionEntry($2->name, $1->type)))
        {
            //already exist function with this name
            errorDef(yylineno,($2)->name);
            exit(1);
        }
        TableEntryFunc* f = (TableEntryFunc*)(current_scope_table->getEntry(($2)->name));
        //create new scope table for function scope
        SymbolTable* new_func_scope = new SymbolTable(current_scope_table);
        //the current scope is the function scope now
        current_scope_table = new_func_scope;
        //add the top value to the offsets stuck
        offsets.push(offsets.top());

        int ParamOffset = offsets.top();
        for (std::vector<FormalDeclNode>::const_iterator it = (dynamic_cast<FormalsNode*>($4))->list.dec_list->begin(); it != (dynamic_cast<FormalsNode*>($4))->list.dec_list->end(); it++)
        {
            /*function aguments are treated as outer scope declered, there for, thire offset's are smaller than the function scope offset.
            specipicaly, the "decleration" order in the outer scope is from the right variab;e in the agruments list, to the right. */
            ParamOffset -= (*it).size;
            if (!(current_scope_table->insertVariableEntry( (*it).name ,(*it).type , ParamOffset )))
            {
                //there is already a variable with the parameter's name
                errorDef(yylineno,(*it).name);
                exit(1);
            }
            f->declaration_list->push_back(*it);
        }
    }
;

//no semantic needed
Structs :   StructDecl Structs
            | /*epsilon*/
;

//i changed STRUCT ID to StrctType to avoid conflict
StructDecl :  M2 SC{
                    std::vector<StructMemNode>* fields_list = ((TableEntryStruct*)(current_scope_table->scope_table.back()))->Fields;
                    endScope();
                    printStructTypeHelp((($2)->name), fields_list); //todo: shani fix $2
                    //popping tops of stack table and stack offsets
                    SymbolTable* parent = current_scope_table->getParent();
                    delete(current_scope_table);
                    current_scope_table = parent;
                    offsets.pop();
                 }
;

// marker 2
M2 : StructType LBRACE StructMemList RBRACE {
            //insertion to current scope's table
            if (!(current_scope_table->insertStructEntry(($2)->name, TYPE_STRUCT))){
                    // id already defined
                    errorDef(yylineno, (($2)->name));
                    exit(1);
            }
            //create new scope table for the scope defined by the struct
            SymbolTable* new_scope_table = new SymbolTable(current_scope_table);
            current_scope_table = new_scope_table;
            //insert the new scope's offset to the offsets stack
            offsets.push(offsets.top());
            //the updating offset of the fields in the struct
            int current_offset = offsets.top();
            //saving a reference to "fields list" field of the struct defined
            std::vector<StructMemNode>* fields_list = ((TableEntryStruct*)((current_scope_table->scope_table).back()))->Fields;
            //iterating over the fields list of the struct
            for (std::vector<StructMemNode>::const_iterator it = ((dynamic_cast<StructMemListNode*>($3))->s_list)->begin(); it != ((dynamic_cast<StructMemListNode*>($3))->s_list)->end(); it++){
                //increment current offset by the current field's size
                current_offset += (*it).size;
                //insert the field as a table entry of the current scope table
                if (!(current_scope_table->insertVariableEntry((*it).name, (*it).type, current_offset))){
                    // id already defined
                    errorDef(yylineno,(*it).name);
                    exit(1);
                }
                //insert field to fields list of the defined struct
                fields_list->push_back(*it);
             }
        }
;

RetType : Type {
                    $$->type = $1->type;
            }
          | VOID {
                    $$->type = TYPE_VOID;
                 }
;

Formals : FormalsList {
                ((dynamic_cast<FormalsNode*>($$))->list).dec_list = (dynamic_cast<FormalsListNode*>($1))->dec_list;
            }
           | /*epsilon*/
;

FormalsList : FormalDecl {
                    ((dynamic_cast<FormalsListNode*>($$))->dec_list)->push_back(*(dynamic_cast<FormalDeclNode*>($1)));
                }
             | FormalDecl COMMA FormalsList{
                    (dynamic_cast<FormalsListNode*>($$))->dec_list = (dynamic_cast<FormalsListNode*>($3))->dec_list;
                    ((dynamic_cast<FormalsListNode*>($$))->dec_list)->push_back(*(dynamic_cast<FormalDeclNode*>($1)));
                }
;

FormalDecl : Type ID {
                    ($$)->type = ($1)->type;
                    ($$)->name = ($2)->name;
                }//todo: function cannot get string?
            | StructType ID {
                    //s_type is "Animal"
                    TableEntryStructType* s_type = (TableEntryStructType*)(current_scope_table->getEntry((dynamic_cast<StructTypeNode*>($1))->name));
                    if (s_type->type != TYPE_STRUCTID){
                       //no such struct
                        errorUndef(yylineno,($1)->name);
                        exit(1);
                    }

                    ($$)->type = TYPE_STRUCTID;
                                ($$)->name = ($2)->name;
                 }
;

StructMemList : StructMem {
                        ((dynamic_cast<StructMemListNode*>($$))->s_list)->push_back(*(dynamic_cast<StructMemNode*>($1)));
                    }
                | StructMem StructMemList{
                        (dynamic_cast<StructMemListNode*>($$))->s_list = (dynamic_cast<StructMemListNode*>($2))->s_list;
                        ((dynamic_cast<StructMemListNode*>($$))->s_list)->push_back(*(dynamic_cast<StructMemNode*>($1)));
                    }
;


StructMem : Type ID SC{
                ($$)->type = ($1)->type;
                ($$)->name = ($2)->name;
              }
;

//no semantics needed
Statements : Statement
            | Statement Statements
;

Statement : M3 RBRACE{
    //todo: shani
                    endScope();
                    //this function does all the things we were askd to do in page 6 when closing a scope. see function ducomentation for more details
                    closeScope();
                    //return the current scope to be the outer scope
                    SymbolTable* parent = current_scope_table->getParent();
                    delete(current_scope_table);
                    current_scope_table = parent;
                    //back to the outer scope pffset
                    offsets.pop();
                }
            | Type ID SC{
                int offset = offsets.top();
                offsets.pop();
                if (!(current_scope_table->insertVariableEntry(($2)->name,($1)->type,offset))){
                    // Id already defined
                    errorDef(yylineno,($2)->name);
                    exit(1);
                }
                offsets.push(offset+1); //update offset
            }

            | StructType ID SC {
                int offset = offsets.top();
                offsets.pop();
                if (!(current_scope_table->insertStructTypeEntry(($2)->name, (dynamic_cast<TableEntryStruct*>($1))->name,TYPE_STRUCTID,offset))){
                    // Id already defined
                    errorDef(yylineno,($2)->name);
                    exit(1);
                 }
                offsets.push(offset+1); //update offset
             }
             //todo: racheli, it was STRUCT ID LBRACE StructMemList RBRACE SC , i changed it to "StructsDecl" - this is another conflict
            | StructDecl

            | Type ID ASSIGN Exp SC{
                int offset = offsets.top();
                offsets.pop();
                if (!(current_scope_table->insertVariableEntry(($2)->name,($1)->type,offset))){
                    // Id already defined
                    errorDef(yylineno,($2)->name);
                    exit(1);
                }
                offsets.push(offset+1); //update offset

                if (($4)->type != ($1)->type){
                    // exp is not the same type as id
                    if ((($4)->type != TYPE_BYTE) || (($1)->type != TYPE_INT)){ // assignment of byte to int is ok
                        errorMismatch(yylineno);
                        exit(1);
                    }
                }
            }

            | StructType ID ASSIGN Exp SC {
                int offset = offsets.top();
                offsets.pop();
                if (!(current_scope_table->insertStructTypeEntry(($2)->name, (dynamic_cast<TableEntryStruct*>($1))->name,TYPE_STRUCTID,offset))){
                    // Id already defined
                    errorDef(yylineno,($2)->name);
                    exit(1);
                }
                offsets.push(offset+1); //update offset

                if (($4)->type != TYPE_STRUCTID){
                    // exp is not structType type
                    errorMismatch(yylineno);
                    exit(1);
                }

                TableEntry* s_s_type_exp = current_scope_table->getEntry(($4)->name);
                //todo: shani: i think we can assume that exp is defined, beacuse this is being checked in the defenition of exp. dont earse it though, leave it for debug
                /* todo: for debug
                 * if(s_s_type_exp == nullptr){
                    //the variable exp was never defined
                    errorUndef(yylineno,(dynamic_cast<IdNode*>($1))->name);
                    exit(1);
                }*/

                if ((dynamic_cast<TableEntryStructType*>($4))->structName != (dynamic_cast<TableEntryStruct*>($1))->name){
                    // exp is not the same structType type
                    errorMismatch(yylineno);
                    exit(1);
                }

             }
//todo: RACHELI from here
            | ID ASSIGN Exp SC
            {
                TableEntryVariable* entry = (TableEntryVariable*)(current_scope_table->getEntry(($1)->name));
                if (!entry)
                {
                    errorUndef(yylineno, ($1)->name);
                    exit(1);
                }

                //check if valid assignment
                if (($3)->type != entry->type || ($3)->size != entry->size)
                {
                    //check if not a byte to int assignment
                    if (!(($3)->type == TYPE_BYTE && entry->type == TYPE_INT))
                    {
                        errorMismatch(yylineno);
                        exit(1);
                    }
                }

                //check if type of var entry is byte and
                //todo: check if strtol is ok (converts string to long int)
                //const char * c = str.c_str();
                const char * c = ((dynamic_cast<ExpNode*>($3))->value).c_str();
                if (entry->type == TYPE_BYTE && std::strtol(c, NULL, 0) > 255)
                {
                    errorByteTooLarge(yylineno, (dynamic_cast<ExpNode*>($3))->value);
                    exit(1);
                }
            }
            | ID PERIOD ID ASSIGN Exp SC
            {
                //check if $1 is struct name and $3 is its field
                TableEntryStruct* s = (TableEntryStruct*)current_scope_table->getEntry(($1)->name);
                if (!s || s->type != TYPE_STRUCTID)
                {
                    errorUndef(yylineno, ($1)->name);
                    exit(1);
                }
                StructMemNode* field = s->getField(($3)->name);
                if (!s)
                {
                    errorUndefStructMember(yylineno, ($3)->name);
                    exit(1);
                }
                //check types assignment match
                if (field->type != ($5)->type)
                {
                    if (!(($5)->type == TYPE_BYTE && field->type == TYPE_INT))
                    {
                        errorMismatch(yylineno);
                        exit(1);
                    }
                }
                //check if legal case type byte
                const char* c = ((dynamic_cast<ExpNode*>($5))->value).c_str();
                if (($5)->type == TYPE_BYTE && std::strtol(c, NULL, 0) > 255)
                {
                    errorByteTooLarge(yylineno, (dynamic_cast<ExpNode*>($5))->value);
                    exit(1);
                }
            }
            | Call SC
            | RETURN SC{
                //get current function scope
                TableEntryFunc* current_function = current_scope_table->getLastFunctionEntry();

                //error if return type of the entry isn't void
                if (current_function->return_type != TYPE_VOID)
                {
                    errorMismatch(yylineno);
                    exit(1);
                }
            }
            | RETURN Exp SC {
                TableEntryFunc* current_function = current_scope_table->getLastFunctionEntry();
                //check if Exp type can be assigned to the functions' return type
                if (current_function->return_type != ($2)->type && !(current_function->return_type == TYPE_INT && ($2)->type == TYPE_BYTE))
                {
                    errorMismatch(yylineno);
                    exit(1);
                }
            }
            | M4 Statement M5{
                endScope();
                SymbolTable* current_parent = current_scope_table->getParent();
                delete(current_scope_table);
                current_scope_table = current_parent;
                offsets.pop();
            }
            | WHILE LPAREN Exp RPAREN M7
               {
                    //turn on flag of loop
                    inside_while = true;
                    //check expression type
                    if (($3)->type != TYPE_BOOL)
                    {
                        errorMismatch(yylineno);
                        exit(1);
                    }
                    SymbolTable* new_scope_table = new SymbolTable(current_scope_table);
                    current_scope_table = new_scope_table;
                    offsets.push(offsets.top());
               }
            | BREAK SC
                {
                    if (!inside_while)
                    {
                        errorUnexpectedBreak(yylineno);
                        exit(1);
                    }
                }
            | CONTINUE SC
                {
                    if (!inside_while)
                    {
                        errorUnexpectedBreak(yylineno);
                        exit(1);
                    }
                }
;
//marker M4
M4  :  IF LPAREN Exp RPAREN {
            if (($3)->type != TYPE_BOOL)
            {
                errorMismatch(yylineno);
                exit(1);
            }
            SymbolTable* new_table = new SymbolTable(current_scope_table);
            current_scope_table = new_table;
            offsets.push(offsets.top());
        }
//marker M5
M5  :  /*epsilon*/  %prec IF
        | ELSE M6
        {
            SymbolTable* new_scope_table = new SymbolTable(current_scope_table);
            current_scope_table = new_scope_table;
            offsets.push(offsets.top());
        }
//marker M6
M6  :   Statement
        {
            endScope();
            SymbolTable* p = current_scope_table->getParent();
            delete(current_scope_table);
            current_scope_table = p;
            offsets.pop();
        }
        %prec ELSE

//marker M7
M7  :   Statement
        {
            endScope();
            SymbolTable* p = current_scope_table->getParent();
            delete(current_scope_table);
            current_scope_table = p;
            offsets.pop();
            //turn off boolean marking that we're out of the while loop
            inside_while = false;
        }

Call : ID LPAREN ExpList RPAREN
        {
            //check that function's name isn't "main", else error
            if (($1)->name == "main")
            {
                //todo: email (what error should we return?) (main should not have parameters list)
                errorMismatch(yylineno);
                exit(1);
            }
            TableEntryFunc* f = (TableEntryFunc*)current_scope_table->getEntry(($1)->name);
            if (!f)
            {
                errorUndef(yylineno, ($1)->name);
                exit(1);
            }
            //compare arguament list to declaration list
            if (!(f->compareArgumentTypes((dynamic_cast<ExpListNode*>($3))->exp_list)))
            {
                //set vector of types as strings to send as parameter to error function
                std::vector<std::string> types;
                for (std::vector<FormalDeclNode>::const_iterator it = f->declaration_list->begin();
                        it != f->declaration_list->end(); it++)
                        {
                            types.push_back(typeToString(it->type));
                        }
                errorPrototypeMismatch(yylineno, ($1)->name, types);
                exit(1);
            }
        (dynamic_cast<CallNode*>($$))->return_type = f->return_type;
        }
        | ID LPAREN RPAREN
        {
            TableEntryFunc* f = (TableEntryFunc*)current_scope_table->getEntry(($1)->name);
            if (!f)
            {
                errorUndefFunc(yylineno, ($1)->name);
                exit(1);
            }

            //should be an empty list of args
            if (f->declaration_list->size() != 0)
            {
                //set vector of types as strings to send as parameter to error function
                std::vector<std::string> types;
                for (std::vector<FormalDeclNode>::const_iterator it = f->declaration_list->begin();
                      it != f->declaration_list->end(); it++)
                         {
                             types.push_back(typeToString(it->type));
                         }
                errorPrototypeMismatch(yylineno, ($1)->name, types);
                exit(1);
            }
            (dynamic_cast<CallNode*>($$))->return_type = f->return_type;
        }
;
//todo: RACHELI to here here

ExpList : Exp {
                // add the experssion to the expression list
                ((dynamic_cast<ExpListNode*>($$))->exp_list)->push_back(*(dynamic_cast<ExpNode*>($1)));
            }
          | Exp COMMA ExpList {
                //current list will be the list it derives with the exp is derives
                (dynamic_cast<ExpListNode*>($$))->exp_list =(dynamic_cast<ExpListNode*>($3))->exp_list;
                ((dynamic_cast<ExpListNode*>($$))->exp_list)->push_back(*(dynamic_cast<ExpNode*>($1)));

            }
;

Type :   INT{(dynamic_cast<TypeNode*>($$))->type = TYPE_INT;}
        | BYTE{(dynamic_cast<TypeNode*>($$))->type = TYPE_BYTE;}
        | BOOL{(dynamic_cast<TypeNode*>($$))->type = TYPE_BOOL;}
;

StructType : STRUCT ID{
                TableEntryStruct* IdVariable = (TableEntryStruct*)current_scope_table->getEntry(($2)->name);
                if(!IdVariable){
                    //the variable was never defined
                    errorUndef(yylineno,($2)->name);
                    exit(1);
                }
                (dynamic_cast<StructTypeNode*>($$))->type = TYPE_STRUCT; //todo: to delete?
                (dynamic_cast<StructTypeNode*>($$))->name = ($2)->name;
            }
;

M3 : LBRACE Statements {
    //todo: shani: has to seperate the open scope and the close scope
        //create new scope table for the scope
        SymbolTable* new_scope = new SymbolTable(current_scope_table);
        //the current scope is the new scope now
        current_scope_table = new_scope;
        //add the top value to the offsets stuck
        offsets.push(offsets.top());
};

Exp : LPAREN Exp RPAREN{
            $$->type = $2->type;
            $$->size = $2->size;
      }

      | Exp SBINOP Exp{
            //binops is defined on int and byte only (among the types that we are using in this project)
            if (((dynamic_cast<ExpNode*>($1))->type != TYPE_INT && (dynamic_cast<ExpNode*>($1))->type != TYPE_BYTE) ||
                                    ((dynamic_cast<ExpNode*>($3))->type != TYPE_INT && (dynamic_cast<ExpNode*>($3))->type != TYPE_BYTE)) {
                errorMismatch(yylineno);
                exit(1);
            }
            (dynamic_cast<ExpNode*>($$))->size = 1; //both INT  and BYTE are size 1
            //the exp type is the type of the bigger of the $1 and $3 expressions
            if ((dynamic_cast<ExpNode*>($1))->type == TYPE_INT  || (dynamic_cast<ExpNode*>($2))->type == TYPE_INT)
                (dynamic_cast<ExpNode*>($$))->type = TYPE_INT;
            else
                (dynamic_cast<ExpNode*>($$))->type = TYPE_BYTE;
        }
      | Exp LBINOP Exp{
            //binops is defined on int and byte only (among the types that we are using in this project)
            if (((dynamic_cast<ExpNode*>($1))->type != TYPE_INT && (dynamic_cast<ExpNode*>($1))->type != TYPE_BYTE) ||
                                    ((dynamic_cast<ExpNode*>($3))->type != TYPE_INT && (dynamic_cast<ExpNode*>($3))->type != TYPE_BYTE)) {
                errorMismatch(yylineno);
                exit(1);
            }
            (dynamic_cast<ExpNode*>($$))->size = 1; //both INT  and BYTE are size 1
            //the exp type is the type of the bigger of the $1 and $3 expressions
            if ((dynamic_cast<ExpNode*>($1))->type == TYPE_INT  || (dynamic_cast<ExpNode*>($2))->type == TYPE_INT)
                (dynamic_cast<ExpNode*>($$))->type = TYPE_INT;
            else
                (dynamic_cast<ExpNode*>($$))->type = TYPE_BYTE;
        }      | ID {
            //we need to check if this variable is defined in the upper or current scopes
            //if this variable is defined, we want to use it, therefore $1.type is not right, because we want the type of the variable, not the type of the token
            TableEntry* IdVariable = current_scope_table->getEntry((dynamic_cast<IdNode*>($1))->name);
            if(!IdVariable){
                //the variable was never defined
                errorUndef(yylineno,(dynamic_cast<IdNode*>($1))->name);
                exit(1);
            }
            // the exp type and size is the variable type and size
            (dynamic_cast<ExpNode*>($$))->type = IdVariable->type;
            (dynamic_cast<ExpNode*>($$))->size = IdVariable->size;
        }

      | ID PERIOD ID{
            //we need to check if this variable is defined in the upper or current scopes
            //if this variable is defined, we want to use it, therefore $1.type is not right, because we want the type of the variable, not the type of the token
            TableEntry* IdVariable = current_scope_table->getEntry(($1)->name);
            if ((!IdVariable || (IdVariable->type != TYPE_STRUCTID) ) ){
                //the variable was never defined or it's type is not a struct type (no such var name dog or dog is not struct animal type)
                errorUndef(yylineno,(dynamic_cast<IdNode*>($1))->name);
                exit(1);
            }

            //s_type is "Animal"
            TableEntryStruct* s_type = (TableEntryStruct*)(current_scope_table->getEntry(IdVariable->name));

            StructMemNode* field = s_type->getField(($3)->name);
            if (!field){
                // no such field
                errorUndefStructMember(yylineno,(dynamic_cast<IdNode*>($1))->name);
                exit(1);
            }
            //else
            (dynamic_cast<ExpNode*>($$))->type = field->type;
            (dynamic_cast<ExpNode*>($$))->size = (dynamic_cast<IdNode*>($1))->size;
        }

      | Call {
            //if the exp derives a function call, it's value will be the return type
            //todo: call should have ReturnType field
            (dynamic_cast<ExpNode*>($$))->type = (dynamic_cast<CallNode*>($1))->return_type;
        }

      | NUM {
            //exp type = num type = int
            (dynamic_cast<ExpNode*>($$))->type = TYPE_INT;
            (dynamic_cast<ExpNode*>($$))->size = 1; //Int size is 1
        }

      | NUM B {
            //exp type = num type = byte
            (dynamic_cast<ExpNode*>($$))->type = TYPE_BYTE;
            (dynamic_cast<ExpNode*>($$))->size = 1; //byte size is 1
          }

      | STRING{
            //exp type = num type = string
            (dynamic_cast<ExpNode*>($$))->type = TYPE_STRING;
            (dynamic_cast<ExpNode*>($$))->size = 1; //string size is 1
        }

      | TRUE{
            //exp type = true type = bool
            (dynamic_cast<ExpNode*>($$))->type = TYPE_BOOL;
            (dynamic_cast<ExpNode*>($$))->size = 1; //bool size is 1
        }

      | FALSE{
            //exp type = false type = bool
            (dynamic_cast<ExpNode*>($$))->type = TYPE_BOOL;
            (dynamic_cast<ExpNode*>($$))->size = 1; //bool size is 1
        }

      | NOT Exp {
            if((dynamic_cast<ExpNode*>($1))->type != TYPE_BOOL){
                //not operator is valid only on bool variables
                errorMismatch(yylineno);
                exit(1);
            }
            (dynamic_cast<ExpNode*>($$))->type = TYPE_BOOL;
            (dynamic_cast<ExpNode*>($$))->size = 1; //bool size is 1
          }

      | Exp AND Exp{
            if((dynamic_cast<ExpNode*>($1))->type != TYPE_BOOL || (dynamic_cast<ExpNode*>($3))->type != TYPE_BOOL){
                //and operator is valid only on bool variables
                errorMismatch(yylineno);
                exit(1);
            }
            (dynamic_cast<ExpNode*>($$))->type = TYPE_BOOL;
            (dynamic_cast<ExpNode*>($$))->size = 1; //bool size is 1
        }
      | Exp OR Exp{
            if((dynamic_cast<ExpNode*>($1))->type != TYPE_BOOL || (dynamic_cast<ExpNode*>($3))->type != TYPE_BOOL){
            //or operator is valid only on bool variables
                errorMismatch(yylineno);
                exit(1);
            }
            (dynamic_cast<ExpNode*>($$))->type = TYPE_BOOL;
            (dynamic_cast<ExpNode*>($$))->size = 1; //bool size is 1
       }

      | Exp ARELOP Exp{
            if((dynamic_cast<ExpNode*>($1))->type != TYPE_INT || (dynamic_cast<ExpNode*>($3))->type != TYPE_INT){
                //and operator is valid only on numerical variables
                errorMismatch(yylineno);
                exit(1);
            }
            (dynamic_cast<ExpNode*>($$))->type = TYPE_BOOL; // return type of relop operator is bool
            (dynamic_cast<ExpNode*>($$))->size = 1; //bool size is 1
       }

      | Exp NARELOP Exp{
        if((dynamic_cast<ExpNode*>($1))->type != TYPE_INT || (dynamic_cast<ExpNode*>($3))->type != TYPE_INT){
            //and operator is valid only on numerical variables
            errorMismatch(yylineno);
            exit(1);
        }
        (dynamic_cast<ExpNode*>($$))->type = TYPE_BOOL; // return type of relop operator is bool
        (dynamic_cast<ExpNode*>($$))->size = 1; //bool size is 1
       }
;


%%

/*USER ROUTINES*/

//todo: RACHELI

void yyerror(std::string m)
{
    //todo: why do we need an input to this function?
    errorSyn(yylineno);
    exit(0);
}

int main() {
    current_scope_table = new SymbolTable(NULL);
    offsets.push(0);
    //std::vector<FormalDeclNode*> decl_list;
    FormalDeclNode* n;
    n->name = "";
    n->type = TYPE_STRING;
    n->size = 1;
    current_scope_table->insertFunctionEntry("print", TYPE_VOID);
    TableEntryFunc* f_print = (TableEntryFunc*)current_scope_table->getEntry("print");
    f_print->declaration_list->push_back(*n);
    n->type = TYPE_INT;
    current_scope_table->insertFunctionEntry("printi", TYPE_VOID);
    TableEntryFunc* f_printi = (TableEntryFunc*)current_scope_table->getEntry("printi");
    f_printi->declaration_list->push_back(*n);
    yyparse();
    int main_counter = 0;
    for (std::vector<TableEntry*>::const_iterator it = current_scope_table->scope_table.begin(); it != current_scope_table->scope_table.end(); it++)
    {
        if (typeid((*it)).name() == "TableEntryFunc")
        {
            if ((*it)->name == "main" && ((TableEntryFunc*)(*it))->return_type == TYPE_VOID && ((TableEntryFunc*)(*it))->declaration_list->size() == 0)
            {
                main_counter++;
            }
        }

    }
    if (main_counter != 1)
    {
        errorMainMissing();
        exit(1);
    }
    endScope();
    delete(current_scope_table);
    //todo: check if main is missing
    //todo: delete global scope
}


void printStructTypeHelp(const string& name, vector<StructMemNode>* fields){
    std::vector<typeName> Types;
    std::vector<string> Names;

    for(vector<StructMemNode>::const_iterator it = fields->begin();it!=fields->end();it++){
        Types.push_back((*it).type);
        Names.push_back((*it).name);
    }
    printStructType(name, TypeVecToString(Types), Names);
}
//todo: (racheli) TYPE_STRUCTID
std::string typeToString(typeName type){
    switch (type){
        case(TYPE_BYTE) :
            return "BYTE";
        case(TYPE_BOOL) :
            return "BOOL";
        case(TYPE_INT) :
            return "INT";
        case(TYPE_STRING) :
            return "STRING";
        case(TYPE_STRUCT) :
            return "STRUCT";
        case(TYPE_VOID) :
            return "VOID";
    }
}

std::vector<string>& TypeVecToString(std::vector<typeName>& t_vec){
    std::vector<string> s_vec;
    for(int i=0; i< t_vec.size(); i++){
       s_vec.push_back(typeToString(t_vec[i]));
    }
    return s_vec;
}

std::vector<typeName>& declToTypes(std::vector<FormalDeclNode>* decls){
    std::vector<typeName> res;
    for(std::vector<FormalDeclNode>::const_iterator it = decls->begin(); it != decls->end(); it++){
        res.push_back((*it).type);
    }
    return res;
}


//todo: shani
void closeScope() {
    //note: type will never be struct (//todo: shani: racheli, i did not implimanted it for struct because you already did in another function)) 11.12 change: i changed it because of the FAQ
    //todo: should we support nested functions?
    //for all arguments in the scope table, print them
    for (std::vector<TableEntry*>::const_iterator it = (current_scope_table->scope_table).begin(); it != (current_scope_table->scope_table).end(); it++) {
        if ((*it)->type == TYPE_FUNC) {
            //we should print by using "makeFunctionType" in this case
            printID((*it)->name,(*it)->offset,makeFunctionType(typeToString(((TableEntryFunc*)(*it))->return_type),TypeVecToString(declToTypes(((TableEntryFunc*)(*it))->declaration_list))));
        } else if ((*it)->type == TYPE_STRUCTID){
            //note: "+" is string concatenation operator
            printID((*it)->name,(*it)->offset,("STRUCT<"+ ((TableEntryStructType*)(*it))->structName + ">"));
        } else if ((*it)->type == TYPE_STRUCT){
            TableEntryStruct* structInfo = (TableEntryStruct*)(*it);
            printStructTypeHelp(structInfo->name, structInfo->Fields);
        }
        else{
            printID((*it)->name,(*it)->offset,typeToString((*it)->type));
        }
    }
}